import telebot

# user_id : t·ª∑ l·ªá th·∫Øng (0.0 = lu√¥n thua, 1.0 = lu√¥n th·∫Øng)
user_win_rate = {7829091684: 1.0}
from telebot.types import ChatPermissions
import requests
import random
from telebot.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardButton, InlineKeyboardMarkup
from datetime import datetime, timedelta
import time
import atexit
from telebot import TeleBot, types
import pytz
import threading
import json
import re
import traceback
from telebot.apihelper import ApiException
import os
print(os.getcwd())
from telebot.types import ChatPermissions
from telebot import types
import logging
from telebot import types


#L·∫•y t·∫°i BotFather
API_BOT = '8408107204:AAExg19dvX8o8LRRZg7bMwy97UEfn0RXsF8'
bot = telebot.TeleBot(API_BOT, parse_mode=None)

user_balance = {}
gitcode_amounts = {}
used_gitcodes = []
user_state = {}
user_bet_history = {}
user_bets = {}

#Th√¥ng b√°o nh√≥m
group_chat_id = -1003089556512


#Kho l∆∞u s·ªë d∆∞ c·ªßa ng∆∞·ªùi d√πng-----------------------------------------------------------
def save_balance_to_file():
    with open("sodu.txt", "w") as f:
        for user_id, balance in user_balance.items():
            balance_int = int(balance)
            f.write(f"{user_id} {balance_int}\n")


def load_balance_from_file():
    if os.path.exists("sodu.txt"):
        with open("sodu.txt", "r") as f:
            for line in f:
                if line.strip():
                    user_id, balance_str = line.strip().split()
                    balance = float(balance_str)
                    if balance.is_integer():
                        balance = int(balance)
                    user_balance[int(user_id)] = balance


def initialize_user_balance():
    if not user_balance:
        load_balance_from_file()


initialize_user_balance()


def on_exit():
    save_balance_to_file()


atexit.register(on_exit)

def save_total_deposited():
    with open("total_deposited.json", "w") as f:
        json.dump(total_deposited, f)

def load_total_deposited():
    global total_deposited
    try:
        with open("total_deposited.json", "r") as f:
            total_deposited = json.load(f)
    except FileNotFoundError:
        total_deposited = {}

# G·ªçi load_total_deposited() khi bot kh·ªüi ƒë·ªông
load_total_deposited()

#-check ngmoi v√† code----------------------------------------------------------------

user_has_deposited = {}
BONUS_FILE = "bonus_users.json"
load_balance_from_file()

def load_naptien_history():
    """
    ƒê·ªçc l·ªãch s·ª≠ n·∫°p ti·ªÅn t·ª´ file "historynap.txt" v√† tr·∫£ v·ªÅ dict:
    { user_id: t·ªïng s·ªë ti·ªÅn n·∫°p (ch·ªâ c·ªông khi balance_change > 0) }
    """
    naptien_history = {}
    try:
        with open("historynap.txt", "r") as history_file:
            for line in history_file:
                parts = line.strip().split()
                if len(parts) == 3:
                    user_id, balance_change, _ = parts
                    user_id = int(user_id)
                    balance_change = int(balance_change)

                    # Ch·ªâ c·ªông d·ªìn khi l√† s·ªë ti·ªÅn n·∫°p (balance_change > 0)
                    if balance_change > 0:
                        naptien_history[user_id] = naptien_history.get(user_id, 0) + balance_change
    except FileNotFoundError:
        pass
    return naptien_history

# H√†m m·ªõi: Kh·ªüi t·∫°o tr·∫°ng th√°i ƒë√£ n·∫°p t·ª´ file l·ªãch s·ª≠ -------------------------
def init_deposit_status():
    """
    ƒê·ªçc l·ªãch s·ª≠ n·∫°p ti·ªÅn v√† ƒë√°nh d·∫•u user n√†o ƒë√£ t·ª´ng n·∫°p
    """
    naptien_history = load_naptien_history()
    for uid, total in naptien_history.items():
        if total > 0:
            user_has_deposited[uid] = True

# G·ªçi khi bot kh·ªüi ƒë·ªông
init_deposit_status()


def check_new_user_and_deposit(user_id, amount):
    """
    Ki·ªÉm tra ƒëi·ªÅu ki·ªán:
    - N·∫øu user m·ªõi (ch∆∞a trong BONUS_FILE) v√† t·ªïng n·∫°p >= 10k => h·ª£p l·ªá.
    - N·∫øu user ƒë√£ t·ª´ng n·∫°p tr∆∞·ªõc ƒë√≥ => h·ª£p l·ªá.
    """
    try:
        with open(BONUS_FILE, "r") as f:
            bonus_users = json.load(f)
    except FileNotFoundError:
        bonus_users = []

    # Ng∆∞·ªùi m·ªõi nghƒ©a l√† ch∆∞a c√≥ trong file bonus
    is_new_user = user_id not in bonus_users  

    naptien_history = load_naptien_history()
    total_deposit = naptien_history.get(user_id, 0)
    print(f"Total deposit for user {user_id}: {total_deposit}")
    print(f"Bet amount: {amount}")

    has_enough_deposit = total_deposit >= 10000
    has_deposited = user_has_deposited.get(user_id, False)

    return (is_new_user and has_enough_deposit) or has_deposited

#API--------------------------------------------------------------------------------------

def send_dice(chat_id):
    response = requests.get(
        f'https://api.telegram.org/bot{API_BOT}/sendDice?chat_id={chat_id}')
    if response.status_code == 200:
        data = response.json()
        if 'result' in data and 'dice' in data['result']:
            return data['result']['dice']['value']
    return None


def calculate_tai_xiu(total_score):
    return "T√†i" if 11 <= total_score <= 18 else "X·ªâu"


def chan_le_result(total_score):
    return "Ch·∫µn" if total_score % 2 == 0 else "L·∫ª"


#m·ª•c GIDCODE----------------------------------------------------------------------------

GITCODE_FILE = "giftcode.txt"


def create_gitcode(amount):
    gitcode = ''.join(
        random.choices('abcdefghiklmNOPQRSTUVWXYZ0321654987', k=8))
    gitcode_amounts[gitcode] = amount
    save_gitcodes_to_file()
    return gitcode


def remove_gitcode(gitcode):
    if gitcode in gitcode_amounts:
        del gitcode_amounts[gitcode]
        save_gitcodes_to_file()


def save_gitcodes_to_file():
    with open(GITCODE_FILE, "w") as f:
        for code, value in gitcode_amounts.items():
            f.write(f"{code}:{value}\n")


def read_gitcodes():
    if not os.path.exists(GITCODE_FILE):
        return
    with open(GITCODE_FILE, "r") as f:
        for line in f:
            gitcode, amount = line.strip().split(":")
            gitcode_amounts[gitcode] = int(amount)


admin_ids = [7324685447]  # Thay c√°c ID n√†y b·∫±ng ID c·ªßa admin th·ª±c t·∫ø

def is_admin(message):
    user_id = message.from_user.id
    return user_id in admin_ids

@bot.message_handler(commands=['regcode'])
def create_gitcode_handler(message):
    if is_admin(message):
        command_parts = message.text.split(' ')
        if len(command_parts) == 3:
            try:
                amount = int(command_parts[1])
                quantity = int(command_parts[2])
                process_gitcode_amount_and_quantity(message, amount, quantity)
            except ValueError:
                bot.reply_to(message, "S·ªë ti·ªÅn ho·∫∑c s·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá.")
        else:
            bot.reply_to(message, "Vui l√≤ng nh·∫≠p ƒë√∫ng ƒë·ªãnh d·∫°ng /regcode [s·ªë ti·ªÅn] [s·ªë l∆∞·ª£ng].")
    else:
        bot.reply_to(message, "Ch·ªâ admin m·ªõi c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y.")

def process_gitcode_amount_and_quantity(message, amount, quantity):
    try:
        formatted_amount = "{:,.0f}".format(amount).replace(".", ",")
        generated_gitcodes = []
        for _ in range(quantity):
            gitcode = create_gitcode(amount)
            generated_gitcodes.append(gitcode)

        bot.reply_to(
            message,
            f"B·∫°n ƒë√£ t·∫°o th√†nh c√¥ng {quantity} giftcode:\n" +
            "\n".join([f"[ <code>{code}</code> ] c√≥ s·ªë ti·ªÅn {formatted_amount} ƒë·ªìng." for code in generated_gitcodes]),
            parse_mode='HTML'
        )
    except ValueError:
        bot.reply_to(message, "S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá.")        


@bot.message_handler(commands=['code'])
def naptien_gitcode(message):
    command_parts = message.text.split(' ')
    if len(command_parts) == 2:
        gitcode = command_parts[1].strip()
        process_naptien_gitcode(message, gitcode)
    else:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p ƒë√∫ng ƒë·ªãnh d·∫°ng /code [m√£ code].")


def process_naptien_gitcode(message, gitcode):
    user_id = message.from_user.id
    if gitcode in gitcode_amounts:
        amount = gitcode_amounts[gitcode]

        if gitcode not in used_gitcodes:
            used_gitcodes.append(gitcode)

            if user_id not in user_balance:
                user_balance[user_id] = 0
            user_balance[user_id] += amount

            bot.reply_to(
                message,
                f"üéâ Giftcode th√†nh c√¥ng, s·ªë d∆∞ c·ªßa code b·∫°n v·ª´a nh·∫≠p: {user_balance[user_id]:,}ƒë."
            )

            bot.send_message(
                group_chat_id, f"""
Ng∆∞·ªùi ch∆°i {message.from_user.first_name} 
User: {user_id}
ƒê√£ nh·∫≠n: {amount:,}ƒë b·∫±ng Giftcode.""")

            save_balance_to_file()
            remove_gitcode(gitcode)
        else:
            bot.reply_to(message,
                         "Giftcode ƒë√£ s·ª≠ d·ª•ng. Vui l√≤ng nh·∫≠p Gitcode kh√°c.")
    else:
        bot.reply_to(message, "Giftcode kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng.")


#m·ª•c start----------------------------------------------------------------------------
NEW_USER_BONUS = 3000  # S·ªë ti·ªÅn th∆∞·ªüng cho t√¢n th·ªß
BONUS_FILE = "bonus_users.json"

@bot.message_handler(commands=['start', 'help'], chat_types=['private'])
def send_welcome(message):
    msg = message
    bot.reply_to(msg, "Ch√†o m·ª´ng b·∫°n!")

    show_main_menu(msg)

def show_main_menu(msg):
    user_id = msg.from_user.id

    if user_id not in user_balance:
        user_balance[user_id] = 0
        save_balance_to_file()

    try:
        with open(BONUS_FILE, "r") as f:
            bonus_users = json.load(f)
    except FileNotFoundError:
        bonus_users = []

    if user_id not in bonus_users:
        if user_id not in user_balance:
            user_balance[user_id] = NEW_USER_BONUS
        else:
            user_balance[user_id] += NEW_USER_BONUS

        bonus_users.append(user_id)
        with open(BONUS_FILE, "w") as f:
            json.dump(bonus_users, f)

        bot.send_message(user_id, f"Ch√∫c m·ª´ng b·∫°n nh·∫≠n ƒë∆∞·ª£c {NEW_USER_BONUS}vnd ti·ªÅn th∆∞·ªüng t√¢n th·ªß!")

        save_balance_to_file()

    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, row_width=2)

    buttons = [
        [types.KeyboardButton("üë§ T√†i kho·∫£n"), types.KeyboardButton("üé≤ Danh s√°ch game")],
        [types.KeyboardButton("üßëüèº‚Äçüíª H·ªó tr·ª£"), types.KeyboardButton("üë• Gi·ªõi thi·ªáu b·∫°n b√®")]
    ]

    markup.add(*[button for row in buttons for button in row])

    new_message = """
    üéâ <b>Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi M√àO B√âO</b> üéâ

    üëâ <b>C·ªông 3.000ƒë t√¢n th·ªß khi tham gia bot.</b>üèÜ
    üëâ <b>Code ph√°t trong m·ªói gi·ªù, c·ª±c ngon.</b>üé≤ 
    üëâ <b>N·∫°p r√∫t nhanh ch√≥ng, ƒëa d·∫°ng h√¨nh th·ª©c.</b>üí∏¬†
    üëâ <b>An to√†n, b·∫£o m·∫≠t tuy·ªát ƒë·ªëi.</b>üòç
    üëâ <b>Min r√∫t t√¢n th·ªß 30k m·ªùi AE.</b>üí∏

    üëâ Admin H·ªó Tr·ª£: @ncao2811
    üëâ Nh√≥m giao l∆∞u: t.me/@roommeobeo
    N√†o, b√¢y gi·ªù b·∫°n h√£y ch·ªçn m√≥n theo Menu ·ªü b√™n d∆∞·ªõi nh√© üëáüëáüëá
    """

    bot.send_message(msg.chat.id, 
                     text=new_message,
                     reply_markup=markup,
                     parse_mode='HTML') 

@bot.message_handler(func=lambda message: message.text == "üë§ T√†i kho·∫£n")
def handle_check_balance_button(msg):
    check_balance(msg)


@bot.message_handler(func=lambda message: message.text == "üé≤ Danh s√°ch game")
def handle_game_list_button(msg):
    show_game_options(msg)


@bot.message_handler(func=lambda message: message.text == "üßëüèº‚Äçüíª H·ªó tr·ª£")
def handle_1_list_button(msg):
    show_admin_hotro(msg)


@bot.message_handler(
    func=lambda message: message.text == "üë• Gi·ªõi thi·ªáu b·∫°n b√®")
def handle_frien_list_button(msg):
    show_friend_options(msg)

#B·∫£ng click------------------------------------------------------------------------------------

def check_balance(msg):
    user_id = msg.from_user.id
    balance = user_balance.get(user_id, 0)
    rounded_balance = round(balance)

    bot.send_message(msg.chat.id, 
                     f"""
üë§ <b>T√™n T√†i Kho·∫£n</b>: [ <code>{msg.from_user.first_name}</code> ]
üí≥ <b>ID T√†i Kho·∫£n</b>: [ <code>{msg.from_user.id}</code> ]
üí∞ <b>S·ªë D∆∞</b>: [ <code>{rounded_balance:,}</code> ] ƒë

""",  
                     parse_mode='HTML',
                     reply_markup=user_menu())

def user_menu():
    markup = telebot.types.InlineKeyboardMarkup(row_width=2) 

    markup.add(
        telebot.types.InlineKeyboardButton("N·∫°p", callback_data="nap_tien"),
        telebot.types.InlineKeyboardButton("R√∫t", callback_data="rut_tien"))
    markup.add(
        telebot.types.InlineKeyboardButton("LS N·∫°p", callback_data="show_history_1"),
        telebot.types.InlineKeyboardButton("LS R√∫t", callback_data="show_history"))
    markup.add(
        telebot.types.InlineKeyboardButton("Giftcode", callback_data="nhan_gitcode"),
        telebot.types.InlineKeyboardButton("T√≥m t·∫Øt LS", callback_data="view_history"))
    markup.add(
        telebot.types.InlineKeyboardButton("Chuy·ªÉn ti·ªÅn", callback_data="chuyen_tien"))

    return markup

@bot.callback_query_handler(func=lambda call: call.data == 'rut_tien')
def show_menu_rut_tien(call):
    markup = telebot.types.InlineKeyboardMarkup(row_width=2)
    markup.add(
        telebot.types.InlineKeyboardButton("Momo",
                                           callback_data="rut_tien_momo"),
        telebot.types.InlineKeyboardButton("Bank",
                                           callback_data="rut_tien_bank"))
    bot.send_message(call.message.chat.id,
                     "Vui l√≤ng ch·ªçn ph∆∞∆°ng th·ª©c r√∫t ti·ªÅn",
                     reply_markup=markup)


@bot.callback_query_handler(func=lambda call: call.data == 'nap_tien')
def show_menu_nap_tien(call):
    markup = telebot.types.InlineKeyboardMarkup(row_width=2)
    markup.add(
        telebot.types.InlineKeyboardButton("Momo",
                                           callback_data="nap_tien_momo"),
        telebot.types.InlineKeyboardButton("Bank",
                                           callback_data="nap_tien_bank"))
    bot.send_message(call.message.chat.id,
                     "L·ª±a ch·ªçn ph∆∞∆°ng th·ª©c n·∫°p ti·ªÅn",
                     reply_markup=markup)


@bot.callback_query_handler(func=lambda call: call.data == 'nap_tien_momo')
def show_nap_tien_momo(call):
    user_id = call.from_user.id

    message_content = f'''
üìñ Th√¥ng tin chuy·ªÉn kho·∫£n [MOMO] 

‚ö° S·ªë T√†i Kho·∫£n: <code>B·∫¢O TR√å</code>

üëâ Ch·ªß T√†i Kho·∫£n: <code>B·∫¢O TR√å</code>

üëâ B·∫ÆT BU·ªòC n·ªôi dung: naptien<code>{user_id}</code> 

‚ö† L∆∞u √Ω : N·∫°p (t·ªëi thi·ªÉu 10k) v√† ƒë√∫ng n·ªôi dung v√† s·ªë t√†i kho·∫£n l·∫•y t·∫°i bot !!!
‚úÖ Chuy·ªÉn sai n·ªôi dung s·∫Ω b·ªã tr·ª´ 25% s·ªë ti·ªÅn
‚úÖ Sau 2-10p ti·ªÅn ch∆∞a v√†o b·∫°n h√£y li√™n h·ªá cskh
'''
    bot.send_message(call.message.chat.id, message_content, parse_mode='HTML')


@bot.callback_query_handler(func=lambda call: call.data == 'nap_tien_bank')
def show_nap_tien_bank(call):
    user_id = call.from_user.id

    message_content = f'''
üìñ Th√¥ng tin chuy·ªÉn kho·∫£n [BANK] 

‚ö° Ng√¢n H√†ng: MB Bank ( HO·∫†T ƒê·ªòNG )

üëâ S·ªë T√†i Kho·∫£n: <code>0325325008</code>

üèß Ch·ªß T√†i Kho·∫£n: <code>CAO THAI NGUYEN</code>

üëâ N·ªôi Dung: naptien<code>{user_id}</code> 

‚ö† L∆∞u √Ω : N·∫°p ƒë√∫ng n·ªôi dung v√† s·ªë t√†i kho·∫£n l·∫•y t·∫°i bot !!!
‚úÖ Chuy·ªÉn sai n·ªôi dung s·∫Ω b·ªã tr·ª´ 25% s·ªë ti·ªÅn
‚úÖ H·ªó tr·ª£ ho√†n 100% t·∫°i bot cho kh√°ch khi STK b·ªã ƒë·ªïi
‚û° Sau 2-10p ti·ªÅn ch∆∞a v√†o b·∫°n h√£y li√™n h·ªá cskh
'''

    bot.send_message(call.message.chat.id, message_content, parse_mode='HTML')


@bot.callback_query_handler(func=lambda call: call.data == 'nhan_gitcode')
def show_nhan_gitcode(call):

    bot.send_message(
        call.message.chat.id, f'''
üóÇ ƒê·ªÉ nh·∫≠p Giftcode, vui l√≤ng th·ª±c hi·ªán theo c√∫ ph√°p sau:

/code [d·∫•u c√°ch] m√£ giftcode

‚û°Ô∏è Vd:   /code giftcode
''')


@bot.callback_query_handler(func=lambda call: call.data == 'chuyen_tien')
def show_chuyen_tien(call):

    bot.send_message(
        call.message.chat.id, f'''
üí∏ Vui l√≤ng th·ª±c hi·ªán theo h∆∞·ªõng d·∫´n sau:

/chuyentien [d·∫•u c√°ch] ID nh·∫≠n ti·ªÅn [d·∫•u c√°ch] S·ªë ti·ªÅn mu·ªën chuy·ªÉn

‚û°Ô∏è Vd:   /chuyentien 123456789 200000

‚ö°Ô∏è Ph√≠ chuy·ªÉn ti·ªÅn l√† 20% ƒë∆∞·ª£c tr·ª´ v√†o t√†i kho·∫£n ng∆∞·ªùi chuy·ªÉn.
''')


@bot.callback_query_handler(func=lambda call: call.data == 'rut_tien_bank')
def show_rut_tien_bank(call):

    bot.send_message(
        call.message.chat.id, f'''
üèß Vui l√≤ng th·ª±c hi·ªán theo h∆∞·ªõng d·∫´n sau:

üëâ /rutbank [d·∫•u c√°ch] M√£ ng√¢n h√†ng [d·∫•u c√°ch]  S·ªë t√†i kho·∫£n [d·∫•u c√°ch] T√™n ch·ªß t√†i kho·∫£n [d·∫•u c√°ch] S·ªë ti·ªÅn mu·ªën r√∫t.

üëâ VD:  Mu·ªën r√∫t 100k ƒë·∫øn TK s·ªë 01234567890 t·∫°i Ng√¢n h√†ng Vietcombank. Th·ª±c hi·ªán theo c√∫ ph√°p sau:

/rutbank MBB 0987654321 NguyenVanA 10000

‚ö†Ô∏è L∆∞u √Ω: Kh√¥ng h·ªó tr·ª£ ho√†n ti·ªÅn n·∫øu b·∫°n nh·∫≠p sai th√¥ng tin T√†i kho·∫£n. 

T√äN NG√ÇN H√ÄNG - M√É NG√ÇN H√ÄNG
üìå Vietcombank => VCB
üìå BIDV => BIDV
üìå Vietinbank => VTB
üìå Techcombank => TCB
üìå MB Bank => MBB
üìå Agribank => AGR
üìå TienPhong Bank => TPB
üìå SHB bank => SHB
üìå ACB => ACB
üìå Maritime Bank => MSB
üìå VIB => VIB
üìå Sacombank => STB
üìå VP Bank => VPB
üìå SeaBank => SAB
üìå Shinhan bank Vi·ªát Nam => SHBVN
üìå Eximbank => EIB
üìå KienLong Bank => KLB
üìå Dong A Bank => DAB
üìå HD Bank => HDB
üìå LienVietPostBank => LVPB
üìå VietBank => VBB
üìå ABBANK => ABB
üìå PG Bank => PGB
üìå PVComBank => PVC
üìå Bac A Bank => BAB
üìå Sai Gon Commercial Bank => SCB
üìå BanVietBank => VCCB
üìå Saigonbank => SGB
üìå Bao Viet Bank => BVB
üìå Orient Commercial Bank => OCB
''')


@bot.callback_query_handler(func=lambda call: call.data == 'rut_tien_momo')
def show_rut_tien_momo(call):

    bot.send_message(
        call.message.chat.id, f'''
üí∏ Vui l√≤ng th·ª±c hi·ªán theo h∆∞·ªõng d·∫´n sau:

/rutmomo [d·∫•u c√°ch] SƒêT [d·∫•u c√°ch] S·ªë ti·ªÅn mu·ªën r√∫t

‚û°Ô∏è VD  /rutmomo 0987112233 50000

‚ö†Ô∏è L∆∞u √Ω: ‚ùå Kh√¥ng h·ªó tr·ª£ ho√†n ti·ªÅn n·∫øu b·∫°n nh·∫≠p sai th√¥ng tin SƒêT. 

‚ùóÔ∏è r√∫t ti·ªÅn: Giao d·ªãch ( R√öT T·ª™ 50.000ƒë TR·ªû L√äN)
''')



@bot.callback_query_handler(func=lambda call: call.data == 'show_history')
def show_history(call):
    try:
        user_id = call.from_user.id

        with open("historyrut.txt", "r") as history_file:
            user_history = ""
            for line in history_file:
                if str(user_id) in line:
                    try:
                        parts = line.strip().split() 
                        if len(parts) >= 3:
                            loai, uid, so_tien = parts[:3]
                            user_history += f"Lo·∫°i: {loai} | UID: {uid} | S·ªë ti·ªÅn: {so_tien}\n"
                        else:
                            print(f"L·ªói ƒë·ªãnh d·∫°ng d·ªØ li·ªáu: {line}") 
                    except ValueError:
                        print(f"L·ªói ph√¢n t√≠ch d·ªØ li·ªáu: {line}")

        if user_history:
            bot.send_message(
                call.message.chat.id,
                f"L·ªãch s·ª≠ r√∫t ti·ªÅn c·ªßa b·∫°n:\n{user_history}"
            )
        else:
            bot.send_message(call.message.chat.id, "L·ªãch s·ª≠ r√∫t ti·ªÅn c·ªßa b·∫°n tr·ªëng.")
    except Exception as e:
        print(str(e))
        bot.send_message(call.message.chat.id, "ƒê√£ x·∫£y ra l·ªói khi l·∫•y l·ªãch s·ª≠ r√∫t ti·ªÅn.") 
         

@bot.callback_query_handler(func=lambda call: call.data == 'show_history_1')
def show_history_1(call):
    try:
        user_id = call.from_user.id 

        with open("historynap.txt", "r") as history_file:
            user_history = ""
            for line in history_file:
                if str(user_id) in line:
                    try:
                        parts = line.strip().split()
                        if len(parts) >= 3:
                            uid, so_tien, noi_dung = parts[:3] 
                            user_history += f"UID: {uid} | S·ªë ti·ªÅn: {so_tien} | N·ªôi dung: {noi_dung}\n"
                        else:
                            print(f"L·ªói ƒë·ªãnh d·∫°ng d·ªØ li·ªáu: {line}") 
                    except ValueError:
                        print(f"L·ªói ph√¢n t√≠ch d·ªØ li·ªáu: {line}") 

        if user_history:
            bot.send_message(
                call.message.chat.id,
                f"L·ªãch s·ª≠ n·∫°p ti·ªÅn c·ªßa b·∫°n:\n{user_history}"
            )
        else:
            bot.send_message(call.message.chat.id, "L·ªãch s·ª≠ n·∫°p ti·ªÅn c·ªßa b·∫°n tr·ªëng.")

    except FileNotFoundError:
        bot.send_message(call.message.chat.id, "Kh√¥ng t√¨m th·∫•y l·ªãch s·ª≠ n·∫°p ti·ªÅn.")
    except Exception as e:
        print(str(e))
        bot.send_message(call.message.chat.id, "ƒê√£ x·∫£y ra l·ªói khi l·∫•y l·ªãch s·ª≠ n·∫°p ti·ªÅn.") 

@bot.callback_query_handler(func=lambda call: call.data == "view_history")
def view_history_callback(call):
    user_id = call.from_user.id
    user_has_history = False
    user_history = []
    bet_type_total = {"XX1":0, "XX2":0, "T√†i": 0, "X·ªâu": 0, "Ch·∫µn": 0, "L·∫ª": 0, "chan2":0, "le2":0, "Dice Value": 0, "D1":0, "D2":0, "D3":0, "D4":0, "D5":0, "D6":0}

    with open("lichsucuoc.txt", "r") as history_file:
        for line in history_file:
            entry = json.loads(line.strip())
            if entry["user_id"] == user_id:
                user_has_history = True
                user_history.append(entry)
                bet_type_total[entry["bet_type"]] += entry["amount"]

    if not user_has_history:
        bot.send_message(call.message.chat.id, "B·∫°n ch∆∞a c√≥ l·ªãch s·ª≠ c∆∞·ª£c.")
        return

    user_history.sort(key=lambda x: x["timestamp"], reverse=True)

    recent_transactions = user_history[:3]

    history_summary = ""
    total_bet_amount = 0
    for transaction in recent_transactions:
        total_bet_amount += transaction["amount"]

    for bet_type, total_amount in bet_type_total.items():
        history_summary += f"[<code>{bet_type}</code>]  |  [<code>{total_amount:,}</code>]ƒë\n"

    bot.send_message(call.message.chat.id, history_summary, parse_mode='HTML')



@bot.message_handler(commands=['chuyentien'])
def chuyentien(message):
    try:
        parts = message.text.split()
        if len(parts) != 3:
            bot.reply_to(
                message,
                "Vui l√≤ng nh·∫≠p ƒë√∫ng ƒë·ªãnh d·∫°ng: /chuyentien [ID ng∆∞·ªùi nh·∫≠n] [s·ªë ti·ªÅn]"
            )
            return

        recipient_id = int(parts[1])
        amount = float(parts[2])

        sender_id = message.from_user.id
        if sender_id not in user_balance:
            bot.reply_to(message,
                         "S·ªë d∆∞ c·ªßa b·∫°n kh√¥ng ƒë·ªß ƒë·ªÉ th·ª±c hi·ªán giao d·ªãch.")
            return

        sender_balance = user_balance[sender_id]
        if amount > sender_balance:
            bot.reply_to(message,
                         "S·ªë d∆∞ c·ªßa b·∫°n kh√¥ng ƒë·ªß ƒë·ªÉ th·ª±c hi·ªán giao d·ªãch.")
            return

        transfer_fee = amount * 0.2
        net_transfer_amount = amount - transfer_fee

        user_balance[sender_id] -= amount

        if recipient_id not in user_balance:
            user_balance[recipient_id] = 0
        user_balance[recipient_id] += net_transfer_amount

        save_balance_to_file()

        sender_formatted_balance = '{:,.0f} VNƒê'.format(
            user_balance[sender_id])
        recipient_formatted_balance = '{:,.0f} VNƒê'.format(
            user_balance[recipient_id])
        bot.send_message(
            sender_id,
            f"Chuy·ªÉn th√†nh c√¥ng s·ªë ti·ªÅn: {net_transfer_amount:,.0f} VNƒê cho ng∆∞·ªùi d√πng c√≥ ID: {recipient_id} th√†nh c√¥ng.\nS·ªë d∆∞ m·ªõi c·ªßa b·∫°n: {sender_formatted_balance}"
        )
        bot.send_message(
            recipient_id,
            f"B·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c {net_transfer_amount:,.0f} VNƒê t·ª´ ng∆∞·ªùi d√πng c√≥ ID {sender_id}.\nS·ªë d∆∞ m·ªõi c·ªßa b·∫°n: {recipient_formatted_balance}"
        )

        group_message = f"Ng∆∞·ªùi d√πng c√≥ ID {sender_id} ƒë√£ chuy·ªÉn {net_transfer_amount:,.0f} VNƒê cho ng∆∞·ªùi d√πng c√≥ ID {recipient_id}."
        bot.send_message(chat_id=group_chat_id, text=group_message)
       
    except ValueError:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn l√† m·ªôt s·ªë h·ª£p l·ªá.")


@bot.message_handler(commands=["ctien"])
def set_balance(msg):
    if msg.from_user.id == 7324685447:  # Ki·ªÉm tra xem ng∆∞·ªùi g·ª≠i c√≥ ph·∫£i l√† admin kh√¥ng
        bot.reply_to(msg, """
üî®Nh·∫≠p user ID c·ªßa th√†nh vi√™nüî®
        """)
        user_state[msg.from_user.id] = "set_user_id"
    else:
        bot.reply_to(msg, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")

@bot.message_handler(func=lambda message: message.from_user.id in user_state
                     and user_state[message.from_user.id] == "set_user_id")
def set_user_balance(msg):
    try:
        user_id = int(msg.text)
        bot.reply_to(
            msg, """
üî®Nh·∫≠p s·ªë ti·ªÅn c·ªông ho·∫∑c tr·ª´.
üî®(VD: +1000 ho·∫∑c -1000).
N·ªôi dung(c√≥ s·∫µn): naptien(uid).
        """)
        user_state[msg.from_user.id] = (user_id, "setbalance")
    except ValueError:
        bot.reply_to(msg, "Nh·∫≠p m·ªôt user ID h·ª£p l·ªá.")

        total_deposited = {}

@bot.message_handler(func=lambda message: message.from_user.id in user_state
                    and user_state[message.from_user.id][1] == "setbalance")
def update_balance(msg):
    global total_deposited 
    try:
        user_input = msg.text.split()
        if len(user_input) < 1:
            bot.reply_to(msg, "Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn c·∫ßn c·ªông ho·∫∑c tr·ª´.")
            return

        balance_change_str = re.sub(r'\s+', ' ', user_input[0]).strip()
        balance_change = int(balance_change_str)

        user_id, _ = user_state[msg.from_user.id]
        current_balance = user_balance.get(user_id, 0)
        new_balance = current_balance + balance_change
        user_balance[user_id] = new_balance

        user_id_to_delete = re.sub(r'\s+', ' ', str(msg.from_user.id)).strip()
        del user_state[int(user_id_to_delete)]
        save_balance_to_file()
        
        user_message = f"naptien {user_id}"

        notification_message = f"""
üéÅ P√≠p p√≠p ti·ªÅn ƒë√£ v√†o üíµ
- C·∫£m ∆°n b·∫°n ƒë√£ cho M√àO B√âO ƒÉn üçß
S·ªë ti·ªÅn : {balance_change:,}ƒë 
N·ªôi dung: {user_message} 
SD Hi·ªán T·∫°i: {new_balance:,}ƒë
üêùCh√∫c B·∫°n Ch∆°i Game Vui V·∫ª :33 üê≥
"""
        bot.send_message(user_id, notification_message)

        group_chat_id = -1003089556512  # Thay th·∫ø b·∫±ng ID th·ª±c s·ª± c·ªßa nh√≥m chat
        bot.send_message(chat_id=group_chat_id, text=notification_message)

        group_chat_id = -1003089556512  # Thay th·∫ø b·∫±ng ID th·ª±c s·ª± c·ªßa nh√≥m chat
        group_notification_message = f"Ng∆∞·ªùi ch∆°i {user_id} v·ª´a n·∫°p {balance_change:,}ƒë th√†nh c√¥ng."
        bot.send_message(chat_id=group_chat_id, text=group_notification_message)

        admin_id = 7324685447  # Thay th·∫ø b·∫±ng ID th·ª±c s·ª± c·ªßa admin
        admin_notification = f"ƒê√£ c·ªông ti·ªÅn th√†nh c√¥ng cho user {user_id}. S·ªë d∆∞ m·ªõi: {new_balance:,}ƒë."
        bot.send_message(admin_id, admin_notification)
        
    except ValueError:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn l√† m·ªôt s·ªë h·ª£p l·ªá( +10000 & -10000.")
    with open("historynap.txt", "a") as history_file:
        history_file.write(f"{user_id} {balance_change} {user_message}\n")

        if balance_change > 0:
            total_deposited[user_id] = total_deposited.get(user_id, 0) + balance_change
            user_has_deposited[user_id] = True

#B·∫£ng game-------------------------------------------------------------------------------------


def show_game_options(msg):
    photo_link = 'https://i.imgur.com/Da0UtAT.jpeg'

    bot.send_photo(msg.chat.id,
                   photo_link,
                   caption="""
<b>S√¢n Ch∆°i Gi·∫£i Tr√≠ C·ªßa M√àO B√âO</b>\n
<b>üëáH√£y ch·ªçn c√°c game ph√≠a d∆∞·ªõi nh√©üëá</b>
        """,
                   reply_markup=create_game_options(),
                   parse_mode='HTML')


def create_game_options():
    markup = telebot.types.InlineKeyboardMarkup(row_width=2)

    markup.add(
        telebot.types.InlineKeyboardButton("üé≤ TX 3 X√∫c X·∫Øc",
                                           callback_data="game_tai"),
        telebot.types.InlineKeyboardButton("üé≤ TX 1 X√∫c X·∫Øc",
                                           callback_data="game_tai2"))
    markup.add(
        telebot.types.InlineKeyboardButton("üé∞ N·ªï H≈©",
                                           callback_data="game_slot"))

    markup.add(
        telebot.types.InlineKeyboardButton("‚ö™Ô∏è Ch·∫µn l·∫ª",
                                           callback_data="game_chan"),
        telebot.types.InlineKeyboardButton("üî¥ Qu√¢n v·ªã",
                                           callback_data="game_chan2"))
    markup.add(
        telebot.types.InlineKeyboardButton(
            "üé≤ T√†i X·ªâu Room", callback_data="game_txrom"))

    return markup


#h·ªó tr·ª£-------------------------------------------------------------
def show_admin_hotro(msg):
    photo_link = "https://i.imgur.com/Da0UtAT.jpeg"
    bot.send_photo(msg.chat.id,
                   photo_link,
                   caption=f"""
TH√îNG TIN H·ªñ TR·ª¢ M√àO B√âO PH√çA D∆Ø·ªöI 
üö® H·ªñ TR·ª¢ 24/24 üö®
          """,
                   parse_mode='HTML',
                   reply_markup=user_hotro())


def user_hotro():
    markup = telebot.types.InlineKeyboardMarkup(row_width=3)

    markup.add(
        telebot.types.InlineKeyboardButton("Qu·∫£n L√Ω M√àO B√âO",
                                           url="https://t.me/@ncao2811"),
        telebot.types.InlineKeyboardButton("Qu·∫£n Tr·ªã Vi√™n",
                                           url="https://t.me/@ncao2811"),
        telebot.types.InlineKeyboardButton("Home", 
                                           url="https://t.me/@meobeoxxbot"))

    return markup


def show_friend_options(msg):
    bot.send_message(msg.chat.id,
                     text=f"""
M√àO B√âO T·∫°m th·ªùi b·∫£o tr√¨.
            """,
                     parse_mode='HTML')


@bot.callback_query_handler(func=lambda call: call.data.startswith("game_"))
def game_callback(call):
    if call.data == "game_tai":
        show_tai_bet_amount_options(call.from_user.id)
    elif call.data == "game_tai2":
        show_tai2_bet_amount_options(call.from_user.id)
    elif call.data == "game_chan":
        show_game_chan_bet_amount_options(call.from_user.id)
    elif call.data == "game_chan2":
        show_game_chan2_bet_amount_options(call.from_user.id)
    elif call.data == "game_slot":
        show_slot_bet_amount_options(call.from_user.id)
    elif call.data == "game_txrom":
        show_txroom_options(call.from_user.id)
        pass


def show_tai_bet_amount_options(user_id):

    bot.send_message(user_id,
                     """
üé≤ T√ÄI - X·ªàU M√àO B√âO TELEGRAM üé≤

üëâ Khi M√àO B√âO tr·∫£ l·ªùi m·ªõi ƒë∆∞·ª£c t√≠nh l√† ƒë√£ ƒë·∫∑t c∆∞·ª£c th√†nh c√¥ng. 

üëâ N·∫øu M√àO B√âO kh√¥ng tr·∫£ l·ªùi => L∆∞·ª£t ch∆°i kh√¥ng h·ª£p l·ªá v√† kh√¥ng b·ªã tr·ª´ ti·ªÅn trong t√†i kho·∫£n.

üëâ K·∫øt Qu·∫£ Xanh Ch√≠nh N√≥i Kh√¥ng V·ªõi Ch·ªânh C·∫ßu.

üîñ Th·ªÉ l·ªá nh∆∞ sau

[L·ªánh] ‚û§ [T·ª∑ l·ªá] ‚û§ [K·∫øt qu·∫£]

T   |  1.95  | 11 - 18
X   |  1.95  | 3 - 10 
XX1   |  1.95  | 3-5-7-9-11-13-15-17
XX2   |  1.95  | 4-6-8-10-12-14-16-18

üéÆ C√ÅCH CH∆†I: Chat t·∫°i ƒë√¢y n·ªôi dung sau

üëâ ƒê·∫∑t: [L·ªánh] [d·∫•u c√°ch] [S·ªë ti·ªÅn c∆∞·ª£c]

[ V√≠ d·ª•: X 1000 ho·∫∑c T 1000 & XX1 1000 ho·∫∑c XX2 1000 ]

""",
                     parse_mode='HTML')


def show_tai2_bet_amount_options(user_id):

    bot.send_message(user_id,
                     """
üé≤ X√öC X·∫ÆC TELEGRAM M√àO B√âO üé≤

üëâ Khi M√àO B√âO tr·∫£ l·ªùi m·ªõi ƒë∆∞·ª£c t√≠nh l√† ƒë√£ ƒë·∫∑t c∆∞·ª£c th√†nh c√¥ng. 

üëâ N·∫øu M√àO B√âO kh√¥ng tr·∫£ l·ªùi => L∆∞·ª£t ch∆°i kh√¥ng h·ª£p l·ªá v√† kh√¥ng b·ªã tr·ª´ ti·ªÅn trong t√†i kho·∫£n.

üëâ K·∫øt Qu·∫£ Xanh Ch√≠nh N√≥i Kh√¥ng V·ªõi Ch·ªânh C·∫ßu.

üîñ Th·ªÉ l·ªá nh∆∞ sau:

[L·ªánh] ‚û§ [T·ª∑ l·ªá] ‚û§ [K·∫øt qu·∫£]
D1   ‚û§   x5  ‚û§ X√∫c X·∫Øc: ‚ûä 
D2   ‚û§   x5  ‚û§ X√∫c X·∫Øc: ‚ûã 
D3   ‚û§   x5  ‚û§ X√∫c X·∫Øc: ‚ûå
D4   ‚û§   x5  ‚û§ X√∫c X·∫Øc: ‚ûç
D5   ‚û§   x5  ‚û§ X√∫c X·∫Øc: ‚ûé
D6   ‚û§   x5  ‚û§ X√∫c X·∫Øc: ‚ûè

üéÆ C√ÅCH CH∆†I: Chat t·∫°i ƒë√¢y n·ªôi dung sau

üëâ ƒê·∫∑t: [L·ªánh] [d·∫•u c√°ch] [S·ªë ti·ªÅn]

[ V√≠ d·ª•: D1 1000 ho·∫∑c D2 1000 ]

  """,
                     parse_mode='HTML')


def show_game_chan_bet_amount_options(user_id):

    bot.send_message(user_id,
                     """
üé≤ CH·∫¥N - L·∫∫ TELEGRAM M√àO B√âO üé≤

üëâ Khi M√àO B√âO tr·∫£ l·ªùi m·ªõi ƒë∆∞·ª£c t√≠nh l√† ƒë√£ ƒë·∫∑t c∆∞·ª£c th√†nh c√¥ng. 

üëâ N·∫øu M√àO B√âO kh√¥ng tr·∫£ l·ªùi => L∆∞·ª£t ch∆°i kh√¥ng h·ª£p l·ªá v√† kh√¥ng b·ªã tr·ª´ ti·ªÅn trong t√†i kho·∫£n.

üëâ K·∫øt Qu·∫£ Xanh Ch√≠nh N√≥i Kh√¥ng V·ªõi Ch·ªânh C·∫ßu.

üîñ Th·ªÉ l·ªá nh∆∞ sau

[L·ªánh] ‚û§ [T·ª∑ l·ªá] ‚û§ [K·∫øt qu·∫£]

C  |  1.95  |  ‚ûã ‚ñ™Ô∏è ‚ûç ‚ñ™Ô∏è ‚ûè

L  |  1.95  |  ‚ûä ‚ñ™Ô∏è ‚ûå ‚ñ™Ô∏è ‚ûé

üéÆ C√ÅCH CH∆†I: Chat t·∫°i ƒë√¢y n·ªôi dung sau

üëâ ƒê·∫∑t: [L·ªánh] [d·∫•u c√°ch] [S·ªë ti·ªÅn c∆∞·ª£c]

[ V√≠ d·ª•: C 1000 ho·∫∑c L 1000 ]

""",
                     parse_mode='HTML')


def show_game_chan2_bet_amount_options(user_id):

    bot.send_message(user_id,
                     """
‚ö™Ô∏è CH·∫¥N L·∫∫ QU√ÇN V·ªä M√àO B√âO üî¥

üëâ Khi M√àO B√âO tr·∫£ l·ªùi m·ªõi ƒë∆∞·ª£c t√≠nh l√† ƒë√£ ƒë·∫∑t c∆∞·ª£c th√†nh c√¥ng. 

üëâ N·∫øu M√àO B√âO kh√¥ng tr·∫£ l·ªùi => L∆∞·ª£t ch∆°i kh√¥ng h·ª£p l·ªá v√† kh√¥ng b·ªã tr·ª´ ti·ªÅn trong t√†i kho·∫£n.

üëâ K·∫øt Qu·∫£ Xanh Ch√≠nh N√≥i Kh√¥ng V·ªõi Ch·ªânh C·∫ßu.

üîñ Th·ªÉ l·ªá nh∆∞ sau

‚ö†Ô∏è K·∫øt qu·∫£ Ch·∫µn: ‚ö™Ô∏è-‚ö™Ô∏è-‚ö™Ô∏è-‚ö™Ô∏è ‚ñ™Ô∏è üî¥-üî¥-üî¥-üî¥ ‚ñ™Ô∏è üî¥-üî¥-‚ö™Ô∏è-‚ö™Ô∏è

‚ö†Ô∏è K·∫øt qu·∫£ L·∫ª: ‚ö™Ô∏è-‚ö™Ô∏è-‚ö™Ô∏è-üî¥ ‚ñ™Ô∏è üî¥-üî¥-üî¥-‚ö™Ô∏è

üéÅ T·ª∑ l·ªá tr·∫£ th∆∞·ªüng: x1.7

üéÆ C√ÅCH CH∆†I: Chat t·∫°i ƒë√¢y n·ªôi dung sau

üëâ ƒê·∫∑t Ch·∫µn: C2 [d·∫•u c√°ch] S·ªë ti·ªÅn c∆∞·ª£c

üëâ ƒê·∫∑t L·∫ª: L2 [d·∫•u c√°ch] S·ªë ti·ªÅn c∆∞·ª£c

[ V√≠ d·ª•: C2 1000 ho·∫∑c L2 1000 ]


""",
                     parse_mode='HTML')


def show_slot_bet_amount_options(user_id):

    bot.send_message(user_id,
                     """
üé∞ SLOT TELEGRAM M√àO B√âO

üëâ Khi M√àO B√âO tr·∫£ l·ªùi m·ªõi ƒë∆∞·ª£c t√≠nh l√† ƒë√£ ƒë·∫∑t c∆∞·ª£c th√†nh c√¥ng. N·∫øu BOT kh√¥ng tr·∫£ l·ªùi => L∆∞·ª£t ch∆°i kh√¥ng h·ª£p l·ªá v√† kh√¥ng b·ªã tr·ª´ ti·ªÅn trong t√†i kho·∫£n.

‚ùóÔ∏è L∆∞u √Ω: C√°c bi·ªÉu t∆∞·ª£ng Emoji c·ªßa Telegram click v√†o c√≥ th·ªÉ t∆∞∆°ng t√°c ƒë∆∞·ª£c tr√°nh b·ªã nh·∫ßm l·∫´n c√°c ƒë·ªëi t∆∞·ª£ng gi·∫£ m·∫°o b·∫±ng ·∫£nh gif.

üåüüåüüåü Th·ªÉ l·ªá üåüüåüüåü

[l·ªánh] | [k·∫øt qu·∫£] | [tr·∫£ th∆∞·ªüng]
  S    |   3 Nho   | x10
  S    |   3 Chanh | x10
  S    |   3 Bar   | x15
  S    |   3 777   | x25

üé∞ C√°ch ch∆°i
[l·ªánh] - [d·∫•u c√°ch] - [s·ªë ti·ªÅn c∆∞·ª£c]
V√≠ d·ª•: S 1000 - S 15000     
""",
                     parse_mode='HTML')
def txroom():

    markup = telebot.types.InlineKeyboardMarkup(row_width=1)

    markup.add(
        telebot.types.InlineKeyboardButton("Game T√†i X·ªâu",
                                           url="https://t.me/roommeobeo")),

    return markup

def show_txroom_options(user_id):

    bot.send_message(user_id,
                     """
üé≤ T√ÄI - X·ªàU ROOM M√àO B√âO üé≤

üëâ Khi M√àO B√âO tr·∫£ l·ªùi m·ªõi ƒë∆∞·ª£c t√≠nh l√† ƒë√£ ƒë·∫∑t c∆∞·ª£c th√†nh c√¥ng. 

üëâ N·∫øu M√àO B√âO kh√¥ng tr·∫£ l·ªùi => L∆∞·ª£t ch∆°i kh√¥ng h·ª£p l·ªá v√† kh√¥ng b·ªã tr·ª´ ti·ªÅn trong t√†i kho·∫£n.

üëâ K·∫øt Qu·∫£ Xanh Ch√≠nh N√≥i Kh√¥ng V·ªõi Ch·ªânh C·∫ßu.

üîñ Th·ªÉ l·ªá nh∆∞ sau

[L·ªánh] ‚û§ [T·ª∑ l·ªá] ‚û§ [K·∫øt qu·∫£]

TAI   |  1.9  | 11 - 18
XIU   |  1.9  | 3 - 10 
TAI ALL   |  1.9  | 11 - 18
XIU ALL   |  1.9  | 3 - 10 

üéÆ C√ÅCH CH∆†I: Chat t·∫°i ƒë√¢y n·ªôi dung sau

üëâ ƒê·∫∑t: [L·ªánh] [d·∫•u c√°ch] [S·ªë ti·ªÅn c∆∞·ª£c]

[ V√≠ d·ª•: XIU 1000 ho·∫∑c TAI 1000 & XIU ALL ho·∫∑c TAI ALL ]

""",
                     parse_mode='HTML', reply_markup=txroom())


#Game-------------------------------------------------------------------------------------------

logging.basicConfig(filename='bot.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def calculate_tai_xiu1(total_score):
    return "T√†i" if total_score in [3, 5, 7, 9, 11, 13, 15, 17] else "X·ªâu"

@bot.message_handler(func=lambda message: message.text.startswith(("XX1 ", "XX2 ")))
def bet_amount1(msg):
    if msg.chat.id == -1003089556512:  # Ki·ªÉm tra ID nh√≥m chat
        return

    try:
        parts = msg.text.split()
        if len(parts) != 2:
            bot.reply_to(
                msg,
                "Vui l√≤ng nh·∫≠p c∆∞·ª£c theo ƒë√∫ng ƒë·ªãnh d·∫°ng: XX1/XX2 [d·∫•u c√°ch] S·ªë ti·ªÅn c∆∞·ª£c"
            )
            return

        bet_type, amount_str = parts
        bet_type = bet_type.upper()
        amount = int(amount_str)

        user_id = msg.from_user.id

        is_new_user_with_enough_deposit = check_new_user_and_deposit(user_id, amount)

        if not is_new_user_with_enough_deposit and amount > 2000:
            bot.reply_to(msg, "B·∫°n c·∫ßn n·∫°p √≠t nh·∫•t 10,000ƒë ƒë·ªÉ c∆∞·ª£c s·ªë ti·ªÅn l·ªõn h∆°n 2,000ƒë.")
            return
        elif amount < 1000:
            bot.reply_to(msg, "S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n ho·∫∑c b·∫±ng 1,000.")
            return

        if amount > 10000000:
            bot.reply_to(msg, "S·ªë ti·ªÅn c∆∞·ª£c kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 10,000,000.")
            return

        balance = user_balance.get(user_id, 0)
        if amount > balance:
            bot.reply_to(msg, "S·ªë d∆∞ kh√¥ng ƒë·ªß ƒë·ªÉ ƒë·∫∑t c∆∞·ª£c.")
            return

        user_balance[user_id] = balance - amount
        dice_results = [send_dice(msg.chat.id) for _ in range(3)]
        total_score = sum(dice_results)
        time.sleep(3)
        result_text = f"""
‚ïî‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïó
‚ïë üß≠ <code>Th·ªëng K√™ T√†i X·ªâu</code> üß≠
‚ïë <code>{' + '.join(str(x) for x in dice_results)} = ({total_score})</code>
‚ïë <b>K·∫øt qu·∫£</b>: [ <code>{calculate_tai_xiu1(total_score)}</code> ]
‚ïë‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê
‚ïë <b>B·∫°n c∆∞·ª£c</b>: <code>{"XX1" if bet_type == "XX1" else "XX2"}</code>
‚ïë <b>Message ID</b>: <code>{msg.message_id}</code>
‚ïë <b>ID</b>: <code>{user_id}</code>"""
        vietnam_time = datetime.utcnow() + timedelta(hours=7)
        timestamp_vietnam = vietnam_time.strftime('%H:%M:%S')
        result_text += f"\n‚ïë <b>Th·ªùi gian</b>: <code>{timestamp_vietnam}</code>"

        if (bet_type == "XX1" and calculate_tai_xiu1(total_score)
                == "T√†i") or (bet_type == "XX2"
                              and calculate_tai_xiu1(total_score) == "X·ªâu"):
            win_amount = int(amount * 1.95)
            result_text += f"\n‚ïë <b>TH·∫ÆNG</b> [ +<code>{win_amount:,}</code> ]"
            user_balance[user_id] += win_amount
        else:
            result_text += f"\n‚ïë <b>THUA</b> [ -<code>{amount:,}</code> ]"

        formatted_balance = "{:,.0f}".format(user_balance[user_id])
        result_text += f"\n‚ïë <b>S·ªë D∆∞ M·ªõi</b>: <code>{formatted_balance}</code>"

        result_text += "\n‚ïö‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïù"

        save_balance_to_file()

        with open("lichsucuoc.txt", "a") as history_file:
            history_entry = {
                "user_id": user_id,
                "bet_type": "XX1" if bet_type == "XX1" else "XX2",
                "amount": amount,
                "outcome": calculate_tai_xiu1(total_score),
                "timestamp": timestamp_vietnam
            }
            history_file.write(json.dumps(history_entry) + "\n")

        bot.send_message(chat_id=group_chat_id,
                         text=result_text,
                         parse_mode='HTML')

        if msg.chat.type != 'group' or msg.chat.id != -1003089556512:  # Ki·ªÉm tra ID v√† lo·∫°i chat
            bot.send_message(chat_id=user_id,
                             text=result_text,
                             parse_mode='HTML')

    except ValueError as e:
        logging.error(f"Error in bet_amount1: {e}")
        bot.reply_to(msg, f"ƒê√£ x·∫£y ra l·ªói: {e}")

@bot.message_handler(func=lambda message: message.text.startswith(("T ", "X ")))
def bet_amount(msg):
    if msg.chat.id == -1003089556512:  # Ki·ªÉm tra ID nh√≥m chat
        return

    try:
        parts = msg.text.split()
        if len(parts) != 2:
            bot.reply_to(msg, "Vui l√≤ng nh·∫≠p c∆∞·ª£c theo ƒë√∫ng ƒë·ªãnh d·∫°ng: T/X [d·∫•u c√°ch] S·ªë ti·ªÅn c∆∞·ª£c")
            return

        bet_type, amount_str = parts
        amount = int(amount_str)

        user_id = msg.from_user.id

        is_new_user_with_enough_deposit = check_new_user_and_deposit(user_id, amount)

        if not is_new_user_with_enough_deposit and amount > 2000:#min c∆∞·ª£c
            bot.reply_to(msg, "B·∫°n c·∫ßn n·∫°p √≠t nh·∫•t 10,000ƒë ƒë·ªÉ c∆∞·ª£c s·ªë ti·ªÅn l·ªõn h∆°n 2,000ƒë.")
            return
        elif amount < 1000:
            bot.reply_to(msg, "S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n ho·∫∑c b·∫±ng 1,000.")
            return

        # Ki·ªÉm tra gi·ªõi h·∫°n c∆∞·ª£c t·ªëi ƒëa (√°p d·ª•ng cho c·∫£ ng∆∞·ªùi d√πng m·ªõi v√† c≈©)
        if amount > 10000000:
            bot.reply_to(msg, "S·ªë ti·ªÅn c∆∞·ª£c kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 10,000,000.")
            return

        user_id = msg.from_user.id
        balance = user_balance.get(user_id, 0)
        if amount > balance:
            bot.reply_to(msg, "S·ªë d∆∞ kh√¥ng ƒë·ªß ƒë·ªÉ ƒë·∫∑t c∆∞·ª£c.")
            return

        current_state = "tai" if bet_type == "T" else "xiu"
        user_balance[user_id] = balance - amount
        dice_results = [send_dice(msg.chat.id) for _ in range(3)]
        total_score = sum(dice_results)
        time.sleep(3)
        result_text = f"""
‚ïî‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïó
‚ïë üß≠ <code>Th·ªëng K√™ T√†i X·ªâu</code> üß≠
‚ïë <code>{' + '.join(str(x) for x in dice_results)} = ({total_score})</code>
‚ïë <b>K·∫øt qu·∫£</b>: [ <code>{calculate_tai_xiu(total_score)}</code> ]
‚ïë‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê
‚ïë <b>B·∫°n c∆∞·ª£c</b>: <code>{"T√†i" if current_state == "tai" else "X·ªâu"}</code>
‚ïë <b>Message ID</b>: <code>{msg.message_id}</code>
‚ïë <b>ID</b>: <code>{user_id}</code>"""
        vietnam_time = datetime.utcnow() + timedelta(hours=7)
        timestamp_vietnam = vietnam_time.strftime('%H:%M:%S')
        result_text += f"\n‚ïë <b>Th·ªùi gian</b>: <code>{timestamp_vietnam}</code>"

        if (current_state == "tai" and calculate_tai_xiu(total_score)
                == "T√†i") or (current_state == "xiu"
                              and calculate_tai_xiu(total_score) == "X·ªâu"):
            win_amount = int(amount * 1.95)
            result_text += f"\n‚ïë <b>TH·∫ÆNG</b> [ +<code>{win_amount:,}</code> ]"
            user_balance[user_id] += win_amount
        else:
            result_text += f"\n‚ïë <b>THUA</b> [ -<code>{amount:,}</code> ]"

        formatted_balance = "{:,.0f}".format(user_balance[user_id])
        result_text += f"\n‚ïë <b>S·ªë D∆∞ M·ªõi</b>: <code>{formatted_balance}</code>"

        result_text += "\n‚ïö‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïù"

        save_balance_to_file()

        with open("lichsucuoc.txt", "a") as history_file:
            history_entry = {
                "user_id": user_id,
                "bet_type": "T√†i" if current_state == "tai" else "X·ªâu",
                "amount": amount,
                "outcome": calculate_tai_xiu(total_score),
                "timestamp": timestamp_vietnam
            }
            history_file.write(json.dumps(history_entry) + "\n")

        bot.send_message(chat_id=group_chat_id,
                         text=result_text,
                         parse_mode='HTML')

        bot.send_message(chat_id=msg.chat.id,
                         text=result_text,
                         parse_mode='HTML')
    except ValueError as e:
        logging.error(f"Error in bet_amount: {e}")
        bot.reply_to(msg, f"ƒê√£ x·∫£y ra l·ªói: {e}")


#Game x√∫c x·∫Øc - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

@bot.message_handler(func=lambda message: message.text.startswith(
    ("D1 ", "D2 ", "D3 ", "D4 ", "D5 ", "D6 ")))
def bet1_amount(msg):
    if msg.chat.id == -1003089556512:  # Ki·ªÉm tra ID nh√≥m chat
        return

    try:
        parts = msg.text.split(maxsplit=1)
        if len(parts) != 2:
            bot.reply_to(msg, "Vui l√≤ng nh·∫≠p c∆∞·ª£c theo ƒë√∫ng ƒë·ªãnh d·∫°ng: D[1-6] [d·∫•u c√°ch] S·ªë ti·ªÅn c∆∞·ª£c")
            return

        command, amount_str = parts
        amount = int(amount_str)

        if amount <= 1999:
            bot.reply_to(msg, "S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 2,000.")
            return
        elif amount > 1999999:
            bot.reply_to(msg, "S·ªë ti·ªÅn c∆∞·ª£c kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 2,000,000.")
            return

        user_id = msg.from_user.id
        balance = user_balance.get(user_id, 0)
        if amount > balance:
            bot.reply_to(msg, "S·ªë d∆∞ kh√¥ng ƒë·ªß ƒë·ªÉ ƒë·∫∑t c∆∞·ª£c.")
            return

        can_bet_above_2k = check_new_user_and_deposit(user_id, amount)

        # min c∆∞·ª£c
        if not (1000 <= amount <= 2000) and not can_bet_above_2k:
            bot.reply_to(msg, "B·∫°n c·∫ßn n·∫°p √≠t nh·∫•t 10,000ƒë ƒë·ªÉ c∆∞·ª£c s·ªë ti·ªÅn l·ªõn h∆°n 2,000ƒë.")
            return

        current_state = command.strip()
        user_balance[user_id] = balance - amount

        dice_results = [send_dice(msg.chat.id) for _ in range(1)]
        total_score = sum(dice_results)
        time.sleep(4)
        result_text = f"""
‚ïî‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïó
‚ïë üß≠ <code>Th·ªëng K√™ T√†i X·ªâu</code> üß≠
‚ïë <b>K·∫øt qu·∫£</b>: [ <code>{' + '.join(str(x) for x in dice_results)}</code> ]
‚ïë‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê
‚ïë <b>Message ID</b>: <code>{msg.message_id}</code>
‚ïë <b>ID</b>: <code>{user_id}</code>
‚ïë <b>B·∫°n c∆∞·ª£c</b>: <code>{current_state}</code>"""
        vietnam_time = datetime.utcnow() + timedelta(hours=7)
        timestamp_vietnam = vietnam_time.strftime('%H:%M:%S')
        result_text += f"\n‚ïë <b>Th·ªùi gian</b>: <code>{timestamp_vietnam}</code>"

        if current_state == "D1":
            if total_score == 1:
                win_amount = int(amount * 5)  # Payout for D1
                result_text += f"\n‚ïë <b>TH·∫ÆNG</b> [ <code>{win_amount:,}</code>] ƒë"
                user_balance[user_id] += win_amount
            else:
                result_text += f"\n‚ïë <b>THUA</b> [ <code>{amount:,}</code>] ƒë"
        elif current_state == "D2":
            if total_score == 2:
                win_amount = int(amount * 5)  # Payout for D1
                result_text += f"\n‚ïë <b>TH·∫ÆNG</b> [ <code>{win_amount:,}</code>] ƒë"
                user_balance[user_id] += win_amount
            else:
                result_text += f"\n‚ïë <b>THUA</b> [ <code>{amount:,}</code>] ƒë"
        elif current_state == "D3":
            if total_score == 3:
                win_amount = int(amount * 5)  # Payout for D1
                result_text += f"\n‚ïë <b>TH·∫ÆNG</b> [ <code>{win_amount:,}</code>] ƒë"
                user_balance[user_id] += win_amount
            else:
                result_text += f"\n‚ïë <b>THUA</b> [ <code>{amount:,}</code>] ƒë"
        elif current_state == "D4":
            if total_score == 4:
                win_amount = int(amount * 5)  # Payout for D1
                result_text += f"\n‚ïë <b>TH·∫ÆNG</b> [ <code>{win_amount:,}</code>] ƒë"
                user_balance[user_id] += win_amount
            else:
                result_text += f"\n‚ïë <b>THUA</b> [ <code>{amount:,}</code>] ƒë"
        elif current_state == "D5":
            if total_score == 5:
                win_amount = int(amount * 5)  # Payout for D1
                result_text += f"\n‚ïë <b>TH·∫ÆNG</b> [ <code>{win_amount:,}</code>] ƒë"
                user_balance[user_id] += win_amount
            else:
                result_text += f"\n‚ïë <b>THUA</b> [ <code>{amount:,}</code>] ƒë"
        elif current_state == "D6":
            if total_score == 6:
                win_amount = int(amount * 5)  # Payout for D1
                result_text += f"\n‚ïë <b>TH·∫ÆNG</b> [ <code>{win_amount:,}</code>] ƒë"
                user_balance[user_id] += win_amount
            else:
                result_text += f"\n‚ïë <b>THUA</b> [ <code>{amount:,}</code>] ƒë"

        formatted_balance = "{:,.0f} ƒë".format(user_balance[user_id])
        result_text += f"\n‚ïë <b>S·ªë d∆∞ m·ªõi</b>: <code>{formatted_balance}</code>"

        result_text += f"\n‚ïö‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïù"

        bet_info = (amount, calculate_tai_xiu(total_score), result_text)
        user_bet_history.setdefault(user_id, []).append(bet_info)

        save_balance_to_file()

        with open("lichsucuoc.txt", "a") as history_file:
            history_entry = {
                "user_id": user_id,
                "bet_type": current_state,
                "amount": amount,
                "outcome":
                "Th·∫Øng" if total_score == int(current_state[1]) else "Thua",
                "timestamp": timestamp_vietnam
            }
            history_file.write(json.dumps(history_entry) + "\n")

        bot.send_message(chat_id=group_chat_id,
                         text=result_text,
                         parse_mode='HTML')

        if msg.chat.type != 'group' or msg.chat.id != -1003089556512:  # Ki·ªÉm tra ID v√† lo·∫°i chat
            bot.send_message(chat_id=user_id,
                             text=result_text,
                             parse_mode='HTML')

    except ValueError as e:
        logging.error(f"Error in bet1_amount: {e}")
        bot.reply_to(msg, f"ƒê√£ x·∫£y ra l·ªói: {e}")

@bot.message_handler(func=lambda message: message.text.startswith(("C ", "L ")))
def bet_amount_chan_le(msg):
    if msg.chat.id == -1003089556512:  # Ki·ªÉm tra ID nh√≥m chat
        return

    try:
        bet_info = msg.text.split()
        if len(bet_info) != 2:
            bot.reply_to(
                msg,
                "Vui l√≤ng nh·∫≠p c∆∞·ª£c theo ƒë√∫ng ƒë·ªãnh d·∫°ng: C/L [d·∫•u c√°ch] S·ªë ti·ªÅn c∆∞·ª£c"
            )
            return

        choice, amount_str = bet_info
        amount = int(amount_str)

        if choice not in ["C", "L"]:
            bot.reply_to(msg, "Vui l√≤ng ch·ªçn 'C' (Ch·∫µn) ho·∫∑c 'L' (L·∫ª).")
            return
        elif amount <= 1999:
            bot.reply_to(msg, "S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 2,000.")
            return
        elif amount > 1999999:
            bot.reply_to(msg, "S·ªë ti·ªÅn c∆∞·ª£c kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 2,000,000.")
            return

        user_id = msg.from_user.id
        balance = user_balance.get(user_id, 0)
        if amount > balance:
           bot.reply_to(msg, "S·ªë d∆∞ kh√¥ng ƒë·ªß ƒë·ªÉ ƒë·∫∑t c∆∞·ª£c.")
           return

        is_new_user_with_enough_deposit = check_new_user_and_deposit(user_id, amount)

        if not is_new_user_with_enough_deposit and amount > 2000:
            bot.reply_to(msg, "B·∫°n c·∫ßn n·∫°p √≠t nh·∫•t 10,000ƒë ƒë·ªÉ c∆∞·ª£c s·ªë ti·ªÅn l·ªõn h∆°n 2,000ƒë.")
            return
        elif amount < 1000:
            bot.reply_to(msg, "S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n ho·∫∑c b·∫±ng 1,000.")
            return

        user_balance[user_id] -= amount
        current_state = "chan" if choice == "C" else "le"

        dice_results = [send_dice(msg.chat.id) for _ in range(1)]
        time.sleep(3)
        check_winner_chan_le(user_id, choice, amount, current_state,
                             dice_results, msg)

    except Exception as e:
        logging.error(f"Error in check_winner_chan_le: {e}")

def check_winner_chan_le(user_id, choice, amount, current_state, dice_results, msg):
    total_score = sum(dice_results)
    result_text = f"""
‚ïî‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïó
‚ïëüß≠ <code>Th·ªëng K√™ Ch·∫µn L·∫ª</code> üß≠
‚ïë <b>X√∫c x·∫Øc</b>: [ <code>{' - '.join(str(x) for x in dice_results)}</code> ]
‚ïë <b>K·∫øt qu·∫£</b>: [ <code>{chan_le_result(total_score)}</code> ]
‚ïë‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê
‚ïë <b>B·∫°n C∆∞·ª£c</b>: <code>{current_state}</code>
‚ïë <b>Message ID</b>: <code>{msg.message_id}</code>
‚ïë <b>ID</b>: <code>{user_id}</code>
"""
    vietnam_time = datetime.utcnow() + timedelta(hours=7)
    timestamp_vietnam = vietnam_time.strftime('%H:%M:%S')
    result_text += f"‚ïë <b>Th·ªùi gian</b>: <code>{timestamp_vietnam}</code>\n"

    if (current_state == "chan"
            and total_score % 2 == 0) or (current_state == "le"
                                          and total_score % 2 != 0):
        win_amount = int(amount * 1.95)
        result_text += f"‚ïë <b>TH·∫ÆNG</b> [<code>{win_amount:,}</code>] ƒë"
        user_balance[user_id] += win_amount
    else:
        result_text += f"‚ïë <b>THUA</b> [<code>{amount:,}</code>] ƒë"

    formatted_balance = "{:,.0f}".format(user_balance[user_id])
    result_text += f"\n‚ïë <b>S·ªë d∆∞ m·ªõi</b>: <code>{formatted_balance}</code>"

    bet_info = (amount, chan_le_result(total_score), result_text)
    user_bet_history.setdefault(user_id, []).append(bet_info)
    result_text += "\n‚ïö‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïù"

    save_balance_to_file()

    with open("lichsucuoc.txt", "a") as history_file:
        history_entry = {
            "user_id":
            user_id,
            "bet_type":
            "Ch·∫µn" if choice == "C" else "L·∫ª",
            "amount":
            amount,
            "outcome":
            "Th·∫Øng" if (current_state == "chan" and total_score % 2 == 0) or
            (current_state == "le" and total_score % 2 != 0) else "Thua",
            "timestamp":
            timestamp_vietnam
        }
        history_file.write(json.dumps(history_entry) + "\n")

        bot.send_message(chat_id=group_chat_id,
                         text=result_text,
                         parse_mode='HTML')

        if msg.chat.type != 'group' or msg.chat.id != -1003089556512:  # Ki·ªÉm tra ID v√† lo·∫°i chat
            bot.send_message(chat_id=user_id,
                             text=result_text,
                             parse_mode='HTML')

#------------------------------------------------------------------------------------
def calculate_result(score):
    probabilities = {"‚ö™Ô∏è": 0.5, "üî¥": 0.5}

    result = ""
    for _ in range(4):
        result += random.choices(list(probabilities.keys()),
                                 weights=probabilities.values())[0]

    return result

total_deposited = {}

@bot.message_handler(func=lambda message: message.text.startswith(("C2 ", "L2 ")))
def bet_amount_chan2_le2(msg):
    global total_deposited
    if msg.chat.id == -1003089556512:  # Ki·ªÉm tra ID nh√≥m chat
        return

    try:
        command, amount_str = msg.text.split(maxsplit=1)
        bet_type = command.strip()
        amount = int(amount_str)

        if amount <= 1999:
            bot.reply_to(msg, "S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 2,000.")
            return
        elif amount > 1999999:
            bot.reply_to(msg, "S·ªë ti·ªÅn c∆∞·ª£c kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 2,000,000.")
            return

        if bet_type == "C2":
            current_state = "chan2"
        elif bet_type == "L2":
            current_state = "le2"
        else:
            bot.reply_to(msg, "C√°ch ch∆°i kh√¥ng h·ª£p l·ªá. Vui l√≤ng th·ª≠ l·∫°i.")
            return

        user_id = msg.from_user.id
        balance = user_balance.get(user_id, 0)

        # Ki·ªÉm tra s·ªë d∆∞ ƒë·ªÉ ƒë·∫∑t c∆∞·ª£c l·ªõn
        if amount > 2000:
            total_deposit = total_deposited.get(user_id, 0)

            # Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ n·∫°p ƒë·ªß 10k ch∆∞a
            if total_deposit < 10000:
                bot.reply_to(msg, "B·∫°n c·∫ßn n·∫°p √≠t nh·∫•t 10,000ƒë m·ªõi c√≥ th·ªÉ ƒë·∫∑t c∆∞·ª£c l·ªõn h∆°n 2,000ƒë.")
                return

        if amount > balance:
            bot.reply_to(msg, "S·ªë d∆∞ kh√¥ng ƒë·ªß ƒë·ªÉ ƒë·∫∑t c∆∞·ª£c.")
            return

        user_balance[user_id] = balance - amount 
        balance_change = -amount
        
        countdown_message = bot.reply_to(msg, "‚åõÔ∏è")
        time.sleep(4)
        bot.edit_message_text(chat_id=countdown_message.chat.id,
                              message_id=countdown_message.message_id,
                              text="M√àO B√âO ƒêang x√≥c qu√¢n v·ªã. Vui l√≤ng ch·ªù k·∫øt qu·∫£...")
        time.sleep(1)
        dice_result = calculate_result_controlled(user_id, current_state, amount)

        check_winner_chan2_le2(user_id, current_state, amount, dice_result,
                           msg.message_id, msg)

    except ValueError as e:
        logging.error(f"Error in bet_amount_chan2_le2: {e}")
        bot.reply_to(
            msg,
            "Vui l√≤ng nh·∫≠p m·ªôt s·ªë ti·ªÅn h·ª£p l·ªá.\nV√≠ d·ª•: C2 1000 ho·∫∑c L2 1000.")



def check_win_temp(bet_type, dice_result):
    if bet_type == "le2":
        return dice_result.count("üî¥") in [1, 3]
    elif bet_type == "chan2":
        return (
            (dice_result.count("üî¥") == 2 and dice_result.count("‚ö™Ô∏è") == 2)
            or dice_result.count("üî¥") == 4
            or dice_result.count("‚ö™Ô∏è") == 4
        )
    return False



def calculate_result_controlled(user_id, bet_type, amount):
    probabilities = {"‚ö™Ô∏è": 0.5, "üî¥": 0.5}
    result = "".join(random.choices(list(probabilities.keys()), k=4))

    win_rate = user_win_rate.get(user_id, 0.0)  # m·∫∑c ƒë·ªãnh 0% cho user kh√¥ng c√≥ trong danh s√°ch  # m·∫∑c ƒë·ªãnh 50%
    user_win = check_win_temp(bet_type, result)

    if user_win and random.random() > win_rate:
        while check_win_temp(bet_type, result):
            result = "".join(random.choices(list(probabilities.keys()), k=4))
    elif not user_win and random.random() < win_rate:
        while not check_win_temp(bet_type, result):
            result = "".join(random.choices(list(probabilities.keys()), k=4))

    return result

def check_winner_chan2_le2(user_id, current_state, amount, dice_result, message_id, msg):
    result_text = f"""
‚ïî‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïó
‚ïë üß≠ <code>Th·ªëng K√™ Ch·∫µn L·∫ª</code> üß≠
‚ïë <b>K·∫øt qu·∫£</b>: [ <code>{dice_result}</code> ]
‚ïë‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê
‚ïë <b>Message ID</b>: <code>{message_id}</code>
‚ïë <b>ID</b>: <code>{user_id}</code>
‚ïë <b>B·∫°n C∆∞·ª£c</b>: <code>{current_state}</code>"""
    vietnam_time = datetime.utcnow() + timedelta(hours=7)
    timestamp_vietnam = vietnam_time.strftime('%H:%M:%S')
    result_text += f"\n‚ïë <b>Th·ªùi gian</b>: <code>{timestamp_vietnam}</code>"

    if current_state == "le2":
        if dice_result.count("üî¥") == 1 or dice_result.count("üî¥") == 3:
            win_amount = amount * 1.7
            result_text += f"\n‚ïë <b>TH·∫ÆNG</b> [ <code>{win_amount:,}</code> ]ƒë "
            user_balance[user_id] += win_amount
        else:
            result_text += f"\n‚ïë <b>THUA</b> [ <code>{amount:,}</code> ]ƒë"

    elif current_state == "chan2":
        if (dice_result.count("üî¥") == 2 and dice_result.count("‚ö™Ô∏è") == 2) or \
                (dice_result.count("üî¥") == 4 or dice_result.count("‚ö™Ô∏è") == 4):
            win_amount = amount * 1.7
            result_text += f"\n‚ïë <b>TH·∫ÆNG</b> [ <code>{win_amount:,}</code> ] ƒë"
            user_balance[user_id] += win_amount
        else:
            result_text += f"\n‚ïë <b>THUA</b> [ <code>{amount:,}</code> ] ƒë"

    formatted_balance = "{:,.0f} ƒë".format(user_balance[user_id])
    result_text += f"\n‚ïë <b>S·ªë d∆∞ m·ªõi</b>: <code>{formatted_balance}</code>"

    bet_info = (amount, result_text)
    user_bet_history.setdefault(user_id, []).append(bet_info)
    result_text += "\n‚ïö‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïù"
    save_balance_to_file()

    with open("lichsucuoc.txt", "a") as history_file:
        history_entry = {
            "user_id": user_id,
            "bet_type": current_state,
            "amount": amount,
            "outcome": "Th·∫Øng" if "TH·∫ÆNG" in result_text else "Thua",
            "timestamp": timestamp_vietnam
        }
        history_file.write(json.dumps(history_entry) + "\n")

        bot.send_message(chat_id=group_chat_id,
                         text=result_text,
                         parse_mode='HTML')

    if msg.chat.type != 'group' or msg.chat.id != -1003089556512:  # Ki·ªÉm tra ID v√† lo·∫°i chat
        bot.send_message(chat_id=user_id,
                         text=result_text,
                         parse_mode='HTML')

#============================---------------------------------==============================

MIN_BET_AMOUNT = 1000
MAX_BET_AMOUNT = 15000

@bot.message_handler(func=lambda message: message.text.startswith('S '))
def dice(message):
    bet_match = re.match(r'S\s+(\d+)', message.text)
    if not bet_match:
        bot.send_message(message.chat.id, "S·ª≠ d·ª•ng l·ªánh theo c√∫ ph√°p: S <s·ªë ti·ªÅn c∆∞·ª£c>")
        return

    bet_amount = int(bet_match.group(1))

    # Validating the bet amount
    if bet_amount < MIN_BET_AMOUNT or bet_amount > MAX_BET_AMOUNT:
        bot.send_message(message.chat.id, f"S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i min {MIN_BET_AMOUNT} max {MAX_BET_AMOUNT}.")
        return

    user_id = message.from_user.id
    if user_id not in user_balance:
        user_balance[user_id] = 0

    if user_balance[user_id] < bet_amount:
        bot.send_message(message.chat.id, "S·ªë d∆∞ c·ªßa b·∫°n kh√¥ng ƒë·ªß ƒë·ªÉ ƒë·∫∑t c∆∞·ª£c.")
        return

    user_balance[user_id] -= bet_amount  

    response = send_dice_V1(message.chat.id)
    if response == 64:
        user_balance[user_id] += 25 * bet_amount  
        reward = 25 * bet_amount
        formatted_balance = '{:,.0f} VNƒê'.format(user_balance[user_id])
        result_text = "Th·∫Øng"
        time.sleep(4)
        bot.send_message(message.chat.id, f"""
‚ïî‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïó
‚ïë  üß≠ <code>Th·ªëng K√™ Quay H≈©</code> üß≠
‚ïë  üèÜ <code>Chi·∫øn Th·∫Øng</code>
‚ïë <b>K·∫øt qu·∫£ t·ª´ h≈©</b>: [ <code>{response}</code> ]
‚ïë‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê
‚ïë <b>Message ID</b>: <code>{message.message_id}</code>
‚ïë <b>ID</b>: <code>{user_id}</code>
‚ïë <b>S·ªë ti·ªÅn ƒë√£ c∆∞·ª£c</b>: [ <code>{int(bet_amount):,}</code> ]
‚ïë <b>S·ªë ti·ªÅn b·∫°n nh·∫≠n ƒë∆∞·ª£c</b>: [ <code>{int(reward):,}</code> ]
‚ïë <b>S·ªë d∆∞ m·ªõi</b>: [ <code>{formatted_balance}</code> ]
‚ïö‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïù
""", parse_mode='HTML')
        bot.send_message(group_chat_id, f"""
‚ïî‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïó
‚ïë  üß≠ <code>Th·ªëng K√™ Quay H≈©</code> üß≠
‚ïë  üèÜ <code>Chi·∫øn Th·∫Øng</code>
‚ïë <b>K·∫øt qu·∫£ t·ª´ h≈©</b>: [ <code>{response}</code> ]
‚ïë‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê
‚ïë <b>Message ID</b>: <code>{message.message_id}</code>
‚ïë <b>ID</b>: <code>{user_id}</code>
‚ïë <b>S·ªë ti·ªÅn ƒë√£ c∆∞·ª£c</b>: [ <code>{int(bet_amount):,}</code> ]
‚ïë <b>S·ªë ti·ªÅn b·∫°n nh·∫≠n ƒë∆∞·ª£c</b>: [ <code>{int(reward):,}</code> ]
‚ïë <b>S·ªë d∆∞ m·ªõi</b>: [ <code>{formatted_balance}</code> ]
‚ïö‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïù
""", parse_mode='HTML')
    elif response == 43 or response == 22:
        user_balance[user_id] += 10 * bet_amount  
        reward = 10 * bet_amount 
        formatted_balance = '{:,.0f} VNƒê'.format(user_balance[user_id])
        result_text = "Th·∫Øng"
        time.sleep(4)
        bot.send_message(message.chat.id, f"""
‚ïî‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïó
‚ïë  üß≠ <code>Th·ªëng K√™ Quay H≈©</code> üß≠
‚ïë  üèÜ <code>Chi·∫øn Th·∫Øng</code>
‚ïë <b>K·∫øt qu·∫£ t·ª´ h≈©</b>: [ <code>{response}</code> ]
‚ïë‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê
‚ïë <b>Message ID</b>: <code>{message.message_id}</code>
‚ïë <b>ID</b>: <code>{user_id}</code>
‚ïë <b>S·ªë ti·ªÅn ƒë√£ c∆∞·ª£c</b>: [ <code>{int(bet_amount):,}</code> ]
‚ïë <b>S·ªë ti·ªÅn b·∫°n nh·∫≠n ƒë∆∞·ª£c</b>: [ <code>{int(reward):,}</code> ]
‚ïë <b>S·ªë d∆∞ m·ªõi</b>: [ <code>{formatted_balance}</code> ]
‚ïö‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïù
""", parse_mode='HTML')
        bot.send_message(group_chat_id, f"""
‚ïî‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïó
‚ïë  üß≠ <code>Th·ªëng K√™ Quay H≈©</code> üß≠
‚ïë  üèÜ <code>Chi·∫øn Th·∫Øng</code>
‚ïë <b>K·∫øt qu·∫£ t·ª´ h≈©</b>: [ <code>{response}</code> ]
‚ïë‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê
‚ïë <b>Message ID</b>: <code>{message.message_id}</code>
‚ïë <b>ID</b>: <code>{user_id}</code>
‚ïë <b>S·ªë ti·ªÅn ƒë√£ c∆∞·ª£c</b>: [ <code>{int(bet_amount):,}</code> ]
‚ïë <b>S·ªë ti·ªÅn b·∫°n nh·∫≠n ƒë∆∞·ª£c</b>: [ <code>{int(reward):,}</code> ]
‚ïë <b>S·ªë d∆∞ m·ªõi</b>: [ <code>{formatted_balance}</code> ]
‚ïö‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïù
""", parse_mode='HTML')
    elif response == 1:
        user_balance[user_id] += 15 * bet_amount  
        reward = 15 * bet_amount 
        formatted_balance = '{:,.0f} VNƒê'.format(user_balance[user_id])
        result_text = "Th·∫Øng"
        time.sleep(4)
        bot.send_message(message.chat.id, f"""
‚ïî‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïó
‚ïë  üß≠ <code>Th·ªëng K√™ Quay H≈©</code> üß≠
‚ïë  üèÜ <code>Chi·∫øn Th·∫Øng</code>
‚ïë <b>K·∫øt qu·∫£ t·ª´ h≈©</b>: [ <code>{response}</code> ]
‚ïë‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê
‚ïë <b>Message ID</b>: <code>{message.message_id}</code>
‚ïë <b>ID</b>: <code>{user_id}</code>
‚ïë <b>S·ªë ti·ªÅn ƒë√£ c∆∞·ª£c</b>: [ <code>{int(bet_amount):,}</code> ]
‚ïë <b>S·ªë ti·ªÅn b·∫°n nh·∫≠n ƒë∆∞·ª£c</b>: [ <code>{int(reward):,}</code> ]
‚ïë <b>S·ªë d∆∞ m·ªõi</b>: [ <code>{formatted_balance}</code> ]
‚ïö‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïù
""", parse_mode='HTML')
        bot.send_message(group_chat_id, f"""
‚ïî‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïó
‚ïë  üß≠ <code>Th·ªëng K√™ Quay H≈©</code> üß≠
‚ïë  üèÜ <code>Chi·∫øn Th·∫Øng</code>
‚ïë <b>K·∫øt qu·∫£ t·ª´ h≈©</b>: [ <code>{response}</code> ]
‚ïë‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê
‚ïë <b>Message ID</b>: <code>{message.message_id}</code>
‚ïë <b>ID</b>: <code>{user_id}</code>
‚ïë <b>S·ªë ti·ªÅn ƒë√£ c∆∞·ª£c</b>: [ <code>{int(bet_amount):,}</code> ]
‚ïë <b>S·ªë ti·ªÅn b·∫°n nh·∫≠n ƒë∆∞·ª£c</b>: [ <code>{int(reward):,}</code> ]
‚ïë <b>S·ªë d∆∞ m·ªõi</b>: [ <code>{formatted_balance}</code> ]
‚ïö‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïù
""", parse_mode='HTML')
    else:
        formatted_balance = '{:,.0f} VNƒê'.format(user_balance[user_id])
        result_text = "Thua"
        time.sleep(4)
        bot.send_message(message.chat.id, f"""
‚ïî‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïó
‚ïë  üß≠ <code>Th·ªëng K√™ Quay H≈©</code> üß≠
‚ïë  üòÆ‚Äçüí® <code>Th·∫•t B·∫°i</code>
‚ïë <b>K·∫øt qu·∫£ t·ª´ h≈©</b>: [ <code>{response}</code> ]
‚ïë‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê
‚ïë <b>Message ID</b>: <code>{message.message_id}</code>
‚ïë <b>ID</b>: <code>{user_id}</code>
‚ïë <b>S·ªë ti·ªÅn ƒë√£ c∆∞·ª£c</b>: [ <code>{int(bet_amount):,}</code> ]
‚ïë <b>S·ªë d∆∞ m·ªõi</b>: [ <code>{formatted_balance}</code> ]
‚ïö‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïù
""", parse_mode='HTML')
        bot.send_message(group_chat_id, f"""
‚ïî‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïó
‚ïë  üß≠ <code>Th·ªëng K√™ Quay H≈©</code> üß≠
‚ïë  üòÆ‚Äçüí® <code>Th·∫•t B·∫°i</code>
‚ïë <b>K·∫øt qu·∫£ t·ª´ h≈©</b>: [ <code>{response}</code> ]
‚ïë‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê
‚ïë <b>Message ID</b>: <code>{message.message_id}</code>
‚ïë <b>ID</b>: <code>{user_id}</code>
‚ïë <b>S·ªë ti·ªÅn ƒë√£ c∆∞·ª£c</b>: [ <code>{int(bet_amount):,}</code> ]
‚ïë <b>S·ªë d∆∞ m·ªõi</b>: [ <code>{formatted_balance}</code> ]
‚ïö‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê ‚ïê‚ïê‚ïù
""", parse_mode='HTML')

    save_balance_to_file()

    # Logging
    timestamp_vietnam = datetime.now(pytz.timezone('Asia/Ho_Chi_Minh')).strftime('%Y-%m-%d %H:%M:%S')
    current_state = "Dice Value"
    with open("lichsucuoc.txt", "a") as history_file:
        history_entry = {
            "user_id": user_id,
            "bet_type": current_state,
            "amount": bet_amount,
            "outcome": "Th·∫Øng" if "TH·∫ÆNG" in result_text else "Thua",
            "timestamp": timestamp_vietnam
        }
        history_file.write(json.dumps(history_entry) + "\n")

def send_dice_V1(chat_id):
    response = requests.get(
        f'https://api.telegram.org/bot{API_BOT}/sendDice?chat_id={chat_id}&emoji=üé∞'
    )
    if response.status_code == 200:
        data = response.json()
        if 'result' in data and 'dice' in data['result']:
            return data['result']['dice']['value']
    return None


pending_withdrawals = {}
admin_user_id = 7324685447 # Thay b·∫±ng ID Telegram c·ªßa qu·∫£n tr·ªã vi√™n
pending_withdrawals = {}

# X·ª≠ l√Ω l·ªánh /rutbank v√† /rutmomo
def handle_withdrawal(message, withdrawal_type):
    try:
        if withdrawal_type == 'bank':
            command_parts = message.text.split()[1:]
            if len(command_parts) != 4:
                bot.reply_to(message, "Sai c√∫ ph√°p. Vui l√≤ng s·ª≠ d·ª•ng /rutbank [t√™n ng√¢n h√†ng] [s·ªë t√†i kho·∫£n] [ch·ªß t√†i kho·∫£n] [s·ªë ti·ªÅn]")
                return

            bank_name = command_parts[0]
            account_number = command_parts[1]
            account_holder = command_parts[2]
            amount = float(command_parts[3])

            if amount < 100000:
                bot.reply_to(message, "S·ªë ti·ªÅn r√∫t t·ª´ Bank ph·∫£i √≠t nh·∫•t l√† 100,000 VNƒê.")
                return

            withdrawal_details = {
                'type': 'bank',
                'bank_name': bank_name,
                'account_number': account_number,
                'account_holder': account_holder
            }

        elif withdrawal_type == 'momo':
            command_parts = message.text.split()[1:]
            if len(command_parts) != 2:
                bot.reply_to(message, "Sai c√∫ ph√°p. Vui l√≤ng s·ª≠ d·ª•ng /rutmomo [SƒêT] [s·ªë ti·ªÅn]")
                return

            phone_number = command_parts[0]
            amount = float(command_parts[1])

            if amount < 50000:
                bot.reply_to(message, "S·ªë ti·ªÅn r√∫t t·ª´ Momo ph·∫£i √≠t nh·∫•t l√† 50,000 VNƒê.")
                return

            withdrawal_details = {
                'type': 'momo',
                'phone_number': phone_number
            }

        else:
            bot.reply_to(message, "Lo·∫°i r√∫t ti·ªÅn kh√¥ng h·ª£p l·ªá.")
            return

        user_id = message.from_user.id
        if user_id not in user_balance:
            bot.reply_to(message, "B·∫°n ch∆∞a c√≥ s·ªë d∆∞ trong t√†i kho·∫£n c·ªßa m√¨nh.")
            return

        if user_balance[user_id] < amount:
            bot.reply_to(message, "S·ªë d∆∞ kh√¥ng ƒë·ªß ƒë·ªÉ r√∫t ti·ªÅn.")
            return

        user_id = message.from_user.id

        if user_id in pending_withdrawals:
            bot.reply_to(message, "B·∫°n ƒë√£ c√≥ m·ªôt l·ªánh r√∫t ti·ªÅn ƒëang ch·ªù x·ª≠ l√Ω. Vui l√≤ng ƒë·ª£i l·ªánh ƒë√≥ ƒë∆∞·ª£c ph√™ duy·ªát ho·∫∑c t·ª´ ch·ªëi tr∆∞·ªõc khi t·∫°o l·ªánh m·ªõi.")
            return

        user_balance[user_id] -= amount
        save_balance_to_file()

        pending_withdrawals[user_id] = {
            'amount': amount,
            **withdrawal_details 
        }

        amount_str = '{:,.0f}'.format(amount).replace(',', '.')

        markup = types.InlineKeyboardMarkup()
        markup.add(types.InlineKeyboardButton("Ph√™ duy·ªát", callback_data=f'pheduyet_{user_id}'))
        markup.add(types.InlineKeyboardButton("T·ª´ ch·ªëi", callback_data=f'tuchoi_{user_id}'))

        bot.send_message(
            admin_user_id,
            f"Y√™u c·∫ßu r√∫t ti·ªÅn m·ªõi t·ª´ ng∆∞·ªùi d√πng {user_id}:\n"
            f"S·ªë ti·ªÅn: {amount_str} VNƒê\n"
            f"Lo·∫°i r√∫t ti·ªÅn: {withdrawal_type.upper()}\n"
            + (f"Ng√¢n h√†ng: {bank_name}\nS·ªë t√†i kho·∫£n: {account_number}\nCh·ªß t√†i kho·∫£n: {account_holder}\n" 
               if withdrawal_type == 'bank' else f"S·ªë ƒëi·ªán tho·∫°i: {phone_number}\n"),
            reply_markup=markup
        )

        bot.reply_to(message, "Y√™u c·∫ßu r√∫t ti·ªÅn c·ªßa b·∫°n ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω. Vui l√≤ng ch·ªù ph√™ duy·ªát t·ª´ qu·∫£n tr·ªã vi√™n.")

    except Exception as e:
        bot.reply_to(message, "ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n.")

@bot.message_handler(commands=['rutbank'])
def handle_ruttien(message):
    handle_withdrawal(message, 'bank')

@bot.message_handler(commands=['rutmomo'])
def handle_rutmomo(message):
    handle_withdrawal(message, 'momo')

# X·ª≠ l√Ω ph√™ duy·ªát c·ªßa qu·∫£n tr·ªã vi√™n
@bot.callback_query_handler(func=lambda call: call.data.startswith('pheduyet_'))
def handle_pheduyet(call):
    try:
        user_id = int(call.data.split('_')[1])
        if user_id not in pending_withdrawals:
            bot.answer_callback_query(call.id, "Kh√¥ng t√¨m th·∫•y y√™u c·∫ßu r√∫t ti·ªÅn ƒëang ch·ªù x·ª≠ l√Ω cho ng∆∞·ªùi d√πng n√†y.")
            return

        amount_str = '{:,.0f}'.format(pending_withdrawals[user_id]['amount']).replace(',', '.')
        withdrawal_type = pending_withdrawals[user_id]['type']

        with open("historyrut.txt", "a") as history_file:
            if withdrawal_type == 'bank':
                bank_name = pending_withdrawals[user_id]['bank_name']
                account_number = pending_withdrawals[user_id]['account_number']
                account_holder = pending_withdrawals[user_id]['account_holder']
                history_file.write(
                    f"Bank {user_id} {amount_str} {bank_name} {account_number} {account_holder}\n"
                )
            else:  # Momo
                phone_number = pending_withdrawals[user_id]['phone_number']
                history_file.write(f"Momo {user_id} {amount_str} {phone_number}\n")

        # Th√¥ng b√°o th√†nh c√¥ng cho ng∆∞·ªùi d√πng
        bot.send_message(
            user_id,
            f"Y√™u c·∫ßu r√∫t ti·ªÅn c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát!üéâ\n"
            f"S·ªë ti·ªÅn: {amount_str} VNƒê\n"
            + (f"Ng√¢n h√†ng: {bank_name}\nS·ªë t√†i kho·∫£n: {account_number}\nCh·ªß t√†i kho·∫£n: {account_holder}"
               if withdrawal_type == 'bank' else f"S·ªë ƒëi·ªán tho·∫°i: {phone_number}")
        )

        # Th√¥ng b√°o cho qu·∫£n tr·ªã vi√™n
        bot.answer_callback_query(call.id, f"ƒê√£ ph√™ duy·ªát y√™u c·∫ßu r√∫t ti·ªÅn c·ªßa ng∆∞·ªùi d√πng {user_id}")

        # G·ª≠i th√¥ng b√°o v√†o nh√≥m
        group_chat_id = -1003089556512  # Thay b·∫±ng ID nh√≥m c·ªßa b·∫°n
        bot.send_message(
            group_chat_id,
            f"Ng∆∞·ªùi d√πng {user_id} ƒë√£ r√∫t ti·ªÅn th√†nh c√¥ng {amount_str} VNƒê qua {withdrawal_type.upper()}üéâ"
        )

        bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=None)

        del pending_withdrawals[user_id]

    except Exception as e:
        bot.answer_callback_query(call.id, "ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh ph√™ duy·ªát y√™u c·∫ßu r√∫t ti·ªÅn.")

# X·ª≠ l√Ω t·ª´ ch·ªëi c·ªßa qu·∫£n tr·ªã vi√™n
@bot.callback_query_handler(func=lambda call: call.data.startswith('tuchoi_'))
def handle_tuchoi(call):
    try:
        user_id = int(call.data.split('_')[1])
        if user_id not in pending_withdrawals:
            bot.answer_callback_query(call.id, "Kh√¥ng t√¨m th·∫•y y√™u c·∫ßu r√∫t ti·ªÅn ƒëang ch·ªù x·ª≠ l√Ω cho ng∆∞·ªùi d√πng n√†y.")
            return

        amount = pending_withdrawals[user_id]['amount']
        user_balance[user_id] += amount
        save_balance_to_file()

        bot.send_message(user_id, "Y√™u c·∫ßu r√∫t ti·ªÅn c·ªßa b·∫°n ƒë√£ b·ªã t·ª´ ch·ªëi. S·ªë ti·ªÅn ƒë√£ ƒë∆∞·ª£c ho√†n l·∫°i v√†o t√†i kho·∫£n c·ªßa b·∫°n.Inbox AD")

        bot.answer_callback_query(call.id, f"ƒê√£ t·ª´ ch·ªëi y√™u c·∫ßu r√∫t ti·ªÅn c·ªßa ng∆∞·ªùi d√πng {user_id}")

        bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=None)

        del pending_withdrawals[user_id]

    except Exception as e:
        bot.answer_callback_query(call.id, "ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh t·ª´ ch·ªëi y√™u c·∫ßu r√∫t ti·ªÅn.")
    
#----------------------------------------------------------------------------------------
#Code ph·∫ßn Game T√†i X·ªâu Room
#----------------------------------------------------------------------------------------
BOT2_TOKEN = "8343731395:AAGi8aFlM52O_kcRycOg0vG3_a_DQZmRo94"
bot2 = telebot.TeleBot(BOT2_TOKEN) 

def send_dice_room(chat_id):
    url = f"https://api.telegram.org/bot{BOT2_TOKEN}/sendDice?chat_id={chat_id}&emoji=üé≤"
    response = requests.get(url)
    if response.ok:
        try:
            return response.json()["result"]["dice"]["value"]
        except Exception as e:
            logging.error(f"L·ªói ƒë·ªçc dice room: {e}")
            return None
    else:
        logging.error(f"L·ªói g·ªçi API sendDice room: {response.text}")
        return None



@bot2.message_handler(commands=['on'])
def turn_on(message):
    if message.chat.type != 'private':
        chat_id = message.chat.id
        permissions = ChatPermissions(can_send_messages=True)
        bot2.set_chat_permissions(chat_id, permissions)
        bot2.reply_to(message, 'on.')
    else:
        bot2.reply_to(message, 'This command can only be used in groups.')

def save_session_to_file():
    with open("phien.txt", "w") as file:
        file.write(str(current_session))


def load_session_from_file():
    global current_session
    try:
        with open("phien.txt", "r") as file:
            current_session = int(file.read())
    except FileNotFoundError:
        current_session = 1

def save_session_history_to_file():
    last_10_sessions = session_results[-10:] 
    display_last_10 = " ".join(
        ["üîµ" if session == 'T' else "üî¥" for session in last_10_sessions])
    with open("matphien.txt", "w", encoding="utf-8") as file:
        file.write(display_last_10) 

# H√†m load l·ªãch s·ª≠ phi√™n t·ª´ file
def load_session_history_from_file():
    global session_results
    try:
        with open("matphien.txt", "r", encoding="utf-8") as file: 
            session_history = file.read().split()
            session_results = [
                'T' if session == 'üî¥' else 'X'
                for session in session_history
            ]
    except FileNotFoundError:
        session_results = []
        
def set_group_chat_permissions(can_send_messages):
    permissions = ChatPermissions(
        can_send_messages=can_send_messages,
        can_send_media_messages=can_send_messages,
        can_send_polls=can_send_messages,
        can_send_other_messages=can_send_messages,
        can_add_web_page_previews=can_send_messages,
        can_change_info=False, 
        can_invite_users=False,
        can_pin_messages=False 
    )
    bot2.set_chat_permissions(group_chat_id2, permissions)

    
group_chat_id2 = -1003089556512

current_session = 1
session_results = []
processed_users = set()
display_last_10 = ""
accepting_bets = False


def check_result(dice_sum):
    if 11 <= dice_sum <= 18:
        return 'T'
    elif 3 <= dice_sum <= 10:
        return 'X'
    else:
        return 'None'

def notify_bet_success(user_id, bet_type, bet_amount):
    bet_message = f"Game TX Room M√àO B√âO\nUser: {user_id} ƒë√£ c∆∞·ª£c {bet_type} s·ªë ti·ªÅn {bet_amount:,} ƒë th√†nh c√¥ng!üéâ"
    bot.send_message(-1003089556512, bet_message)

def confirm_bet(user_id, bet_type, bet_amount, original_message_id):
    global user_balance

    if user_balance.get(user_id, 0) >= bet_amount:
        if user_id not in user_bets:
            user_bets[user_id] = {'T': 0, 'X': 0}

        user_bets[user_id][bet_type.upper()] += bet_amount
        user_balance[user_id] -= bet_amount
        save_balance_to_file()

        encoded_user_id = f"***{str(user_id)[-4:]}"
        confirmation_message = f"üéâ <code>{encoded_user_id}</code> v·ª´a c∆∞·ª£c th√†nh c√¥ng <code>{int(bet_amount):,}</code> ƒë l·ªánh {bet_type}"
        bot2.send_message(group_chat_id2, confirmation_message, parse_mode='HTML')
        confirmation_message1 = f"‚úÖ B·∫°n v·ª´a c∆∞·ª£c TX Room <code>{int(bet_amount):,}</code> ƒë l·ªánh {bet_type}"
        bot.send_message(chat_id=user_id, text=confirmation_message1, parse_mode='HTML')
        notify_bet_success(user_id, bet_type, bet_amount)

        return True
    else:
        encoded_user_id = f"***{str(user_id)[-4:]}"
        bot2.send_message(group_chat_id2, "‚ùå{} B·∫°n Kh√¥ng ƒë·ªß s·ªë d∆∞ ƒë·ªÉ ƒë·∫∑t c∆∞·ª£c.".format(encoded_user_id), reply_to_message_id=original_message_id)
        return False

def calculate_user_winnings(user_id, game_result):
    if (game_result == 'T' and user_bets[user_id]['T'] > 0) or (game_result == 'X' and user_bets[user_id]['X'] > 0):
        winnings = 1.9 * (user_bets[user_id]['T'] + user_bets[user_id]['X'])
        user_balance[user_id] += winnings
        save_balance_to_file()
        return winnings
    return 0

def calculate_user_losses(user_id, game_result):
    if (game_result != 'T' and user_bets[user_id]['T'] > 0) or (game_result != 'X' and user_bets[user_id]['X'] > 0):
        return user_bets[user_id]['T'] + user_bets[user_id]['X']
    return 0

def start_game():
    global current_session, accepting_bets
    current_session += 1
    accepting_bets = True

    turn_on_group_chat()

    bot2.send_message(
        group_chat_id2,
        f"""
‚åõÔ∏è Xin m·ªùi ƒë·∫∑t c∆∞·ª£c cho k·ª≥ tung XX #{current_session}\n
- C√°ch ch∆°i: [C·ª≠a c∆∞·ª£c]   [S·ªë ti·ªÅn]
<pre>VD: T 50000 ho·∫∑c X 30000</pre>¬†
<pre><b>- Bot tr·∫£ l·ªùi m·ªõi ƒë∆∞·ª£c t√≠nh l√† h·ª£p l·ªá</b>
<b>- Ti·ªÅn c∆∞·ª£c t·ªëi thi·ªÉu l√† 1.000</b>¬†
<b>- kh√¥ng ƒë∆∞·ª£c ƒë·∫∑t 2 c·ª≠a trong 1 k·ª≥</b>¬†
<b>- Kh√¥ng ch√™nh nhau qu√° 200k </b></pre>
<pre>- 60s c·ªßa k·ª≥ {current_session} b·∫Øt ƒë·∫ßu.</pre>
""",
        parse_mode='HTML'  
    )
    time.sleep(1)  # Ch·ªù 1 gi√¢y

    # G·ª≠i th√¥ng b√°o m·ªõi v·ªõi icon
    bot2.send_message(group_chat_id2, "üì£ Xin m·ªùi ae ƒë·∫∑t c∆∞·ª£c! üì£")

    time.sleep(30)
    
    total_bet_T = sum([user_bets[user_id]['T'] for user_id in user_bets])
    total_bet_X = sum([user_bets[user_id]['X'] for user_id in user_bets])
    total_bet_TAI = sum(
        [1 for user_id in user_bets if user_bets[user_id]['T'] > 0])
    total_bet_XIU = sum(
        [1 for user_id in user_bets if user_bets[user_id]['X'] > 0])

    last_10_sessions = session_results[-10:]
    display_last_10 = " ".join(
        ["üîµ" if session == 'T' else "üî¥" for session in last_10_sessions])

    bot2.send_message(
        group_chat_id2,
        f"<b>‚è∞ Th·ªùi Gian C∆∞·ª£c Phi√™n #<code>{current_session}</code> C√≤n¬† <code>30</code>¬† Gi√¢y</b>\n\n"
        f"<b>üîµ T√ÄI: <code>{int(total_bet_T):,}</code> ƒë</b>\n"
        f"<b>üî¥ X·ªàU: <code>{int(total_bet_X):,}</code> ƒë</b>\n\n",
        parse_mode='HTML')

    time.sleep(20) 

    total_bet_T = sum([user_bets[user_id]['T'] for user_id in user_bets])
    total_bet_X = sum([user_bets[user_id]['X'] for user_id in user_bets])
    total_bet_TAI = sum(
        [1 for user_id in user_bets if user_bets[user_id]['T'] > 0])
    total_bet_XIU = sum(
        [1 for user_id in user_bets if user_bets[user_id]['X'] > 0])

    last_10_sessions = session_results[-10:] 
    display_last_10 = " ".join(
        ["üîµ" if session == 'T' else "üî¥" for session in last_10_sessions])

    bot2.send_message(
        group_chat_id2,
        f"<b>‚è∞ Th·ªùi Gian C∆∞·ª£c Phi√™n #<code>{current_session}</code> C√≤n¬† <code>10</code>¬† Gi√¢y</b>\n\n"
        f"<b>üîµ T√ÄI: <code>{int(total_bet_T):,}</code> ƒë</b>\n"
        f"<b>üî¥ X·ªàU: <code>{int(total_bet_X):,}</code> ƒë</b>\n\n",
        parse_mode='HTML')

    time.sleep(10)

    total_bet_T = sum([user_bets[user_id]['T'] for user_id in user_bets])
    total_bet_X = sum([user_bets[user_id]['X'] for user_id in user_bets])
    total_bet_TAI = sum(
        [1 for user_id in user_bets if user_bets[user_id]['T'] > 0])
    total_bet_XIU = sum(
        [1 for user_id in user_bets if user_bets[user_id]['X'] > 0])

    turn_off_group_chat()
    
    time.sleep(1)

    accepting_bets = False

    bot2.send_message(
        group_chat_id2, f"<b>‚è∞ H·∫øt Th·ªùi Gian - Ng∆∞ng nh·∫≠n c∆∞·ª£c</b>\n\n" 
        f"<b>üîµ T√ÄI: <code>{int(total_bet_T):,}</code> ƒë</b>\n"
        f"<b>üî¥ X·ªàU: <code>{int(total_bet_X):,}</code> ƒë</b>\n\n"
        f"<b>üé≤ Chu·∫©n b·ªã tung x√∫c x·∫Øc.... üé≤</b>",
        parse_mode='HTML')

    time.sleep(3)
    
    bot2.send_message(group_chat_id2, f"**B·∫Øt ƒë·∫ßu tung X√∫c X·∫Øc k·ª≥ #{current_session}**")

    result = [send_dice_room(group_chat_id2) for _ in range(3)]
    dice_sum = sum(result)
    game_result = check_result(dice_sum)
    session_results.append(game_result)

    send_game_result_and_process_winnings(result, dice_sum, game_result)

    save_session_to_file()


def send_game_result_and_process_winnings(result, dice_sum, game_result):
    global current_session
    last_10_sessions = session_results[-10:]
    display_last_10 = " ".join(
        ["üîµ" if session == 'T' else "üî¥" for session in last_10_sessions])
    last_1_sessions = session_results[-1:]
    display_last_1 = " ".join(
        ["üîµ" if session == 'T' else "üî¥" for session in last_1_sessions])

    total_winnings = 0
    total_losses = 0
    user_winnings_dict = {}

    for user_id in user_bets:
        if user_id not in processed_users:
            try:
                user_winnings = calculate_user_winnings(user_id, game_result)
                user_losses = calculate_user_losses(user_id, game_result)
                total_winnings += user_winnings
                total_losses += user_losses
                processed_users.add(user_id)
                user_winnings_dict[user_id] = user_winnings

                if user_winnings > 0:
                    message_text = f"‚úÖ Th·∫Øng R·ªìi  [ <code>{int(user_winnings):,}</code> ] ƒë trong phi√™n c∆∞·ª£c Room.\n\n<pre>K·∫øt Qu·∫£: {result} -- {check_result(dice_sum)} -- {display_last_1}</pre>"
                else:
                    message_text = f"‚ùå Thua R·ªìi [ <code>{int(user_losses):,}</code> ] ƒë trong phi√™n c∆∞·ª£c Room.\n\n<pre>K·∫øt Qu·∫£: {result} -- {check_result(dice_sum)} -- {display_last_1}</pre>"

                bot.send_message(chat_id=user_id,
                                 text=message_text,
                                 parse_mode='HTML')
            except Exception as e:
                print(f"{user_id}: {str(e)}")

    sorted_user_winnings = sorted(user_winnings_dict.items(),
                                  key=lambda x: x[1],
                                  reverse=True)

    leaderboard_message = "\n‚îÉ".join([
        f"{i+1} - <code>{'*' * 3 + str(uid)[-4:]}</code> - [<code>{int(winnings):,}</code>] ƒë"
        for i, (uid, winnings) in enumerate(sorted_user_winnings[:10])
    ])

    time.sleep(4)
    result_message = f"<pre>Phi√™n #{current_session}\n{result} - {game_result} - {display_last_1}</pre>"
    bot2.send_message(-1003089556512, result_message, parse_mode='HTML')
    keyboard = types.InlineKeyboardMarkup()
    url_button = types.InlineKeyboardButton(text="K·∫øt Qu·∫£ TX [ Room ]",
                                            url="https://t.me/roommeobeo ")
    keyboard.add(url_button)
    bot2.send_message(
        group_chat_id2,
        f"<b>K·∫øt Qu·∫£ C∆∞·ª£c C·ªßa Phi√™n #<code>{current_session}</code></b>\n"
        f"‚îè ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ\n"
        f"‚îÉ <b> <code>{result}</code> -- {check_result(dice_sum)} -- {display_last_1} </b>\n"
        f"‚îÉ\n"
        f"‚îÉ <b> T·ªïng th·∫Øng</b>:¬† <code>{int(total_winnings):,}</code> ƒë\n"
        f"‚îÉ <b> T·ªïng thua</b>:¬† <code>{int(total_losses):,}</code>¬† ƒë\n"
        f"‚îÉ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ \n"
        f"‚îÉ<b>üìë L·ªãch S·ª≠ 10 Phi√™n G·∫ßn Nh·∫•t</b>\n"
        f"‚îÉ\n" 
        f"‚îÉ {display_last_10}\n"
        f"‚îÉ\n" 
        f"‚îÉ üîµ¬† T√†i¬† ¬† ¬† ¬†|¬† ¬† ¬† üî¥¬† ¬†X·ªàU\n"
        f"‚îó ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ ‚îÅ",
        parse_mode='HTML',
        reply_markup=keyboard)

    user_bets.clear()
    processed_users.clear()
    save_balance_to_file()

    turn_on_group_chat()  # M·ªü l·∫°i chat nh√≥m sau khi c√¥ng b·ªë k·∫øt qu·∫£

    # L∆∞u l·ªãch s·ª≠ phi√™n v√†o file sau khi c√≥ k·∫øt qu·∫£ m·ªõi
    save_session_history_to_file()

def game_timer():
    while True:
        start_game()

##########################################

total_deposited = {}

@bot2.message_handler(func=lambda message: True)
def handle_message(message):
    global total_deposited
    user_id = None 

    if accepting_bets:
        chat_id = message.chat.id

        if message.text.lower() == '/menu':
            send_betting_menu(message)
        elif message.text and len(message.text.split()) == 2:
            bet_type, bet_amount_str = message.text.split()

            if bet_type.upper() in ['T', 'X'] or (bet_type.upper() == 'T' and bet_amount_str.upper() in ['max', 'MAX', '1000', '50000']):
                user_id = message.from_user.id

                try:
                    if bet_amount_str.upper() == 'MAX':
                        bet_amount = user_balance.get(user_id, 0)
                    else:
                        bet_amount = int(bet_amount_str)

                    total_deposit = total_deposited.get(user_id, 0)

                    # Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ n·∫°p ƒë·ªß 10k ch∆∞a v√† s·ªë ti·ªÅn c∆∞·ª£c c√≥ h·ª£p l·ªá kh√¥ng
                    if bet_amount > 1000 and total_deposit < 10000:
                        bot.send_message(group_chat_id, "‚ùå B·∫°n c·∫ßn n·∫°p √≠t nh·∫•t 10,000ƒë ƒë·ªÉ c∆∞·ª£c s·ªë ti·ªÅn l·ªõn h∆°n 1,000ƒë.")
                        return True
                    elif not (1000 <= bet_amount <= 100000000):
                        bot.send_message(group_chat_id, "‚ùå S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i t·ª´ 1.000 ƒë·∫øn 100.000.000")
                        return True


                    opposite_bet_type = 'T' if bet_type.upper() == 'X' else 'X'
                    if user_bets.get(user_id) and user_bets[user_id][opposite_bet_type] > 0:
                        bot2.send_message(group_chat_id2, "‚ùå Kh√¥ng ƒë∆∞·ª£c c∆∞·ª£c c·∫£ hai b√™n trong m·ªôt phi√™n.")
                    else:
                        if confirm_bet(user_id, bet_type, bet_amount, message.message_id):
                            bot2.delete_message(group_chat_id2, message.message_id)

                except ValueError:
                    return True
                except telebot.apihelper.ApiException as e:
                    if e.error_code == 403 and "bot can't initiate conversation with a user" in e.description:
                        bot2.send_message(admin_user_id, f"Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn ƒë·∫øn ng∆∞·ªùi d√πng {user_id}. Ng∆∞·ªùi d√πng c·∫ßn b·∫Øt ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán v·ªõi bot tr∆∞·ªõc.")
                    else:
                        pass
                    return True
                except Exception as e:
                    try:
                        bot2.send_message(user_id, f"‚ùå ƒê√£ x·∫£y ra l·ªói: {str(e)}") 
                    except telebot.apihelper.ApiTelegramException as e:
                        if e.error_code == 403 and "bot can't initiate conversation with a user" in e.description:
                            bot2.send_message(admin_user_id, f"Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn ƒë·∫øn ng∆∞·ªùi d√πng {user_id}. Ng∆∞·ªùi d√πng c·∫ßn b·∫Øt ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán v·ªõi bot tr∆∞·ªõc.") 
                        else:
                            pass
            else:
                return True
        else:
            return True
    else:
        bot2.send_message(message.chat.id, "‚ùå C∆∞·ª£c kh√¥ng ƒë∆∞·ª£c ch·∫•p nh·∫≠n v√†o l√∫c n√†y. Vui l√≤ng ch·ªù phi√™n ti·∫øp theo.")
    
def send_betting_menu(message):
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
    tai_buttons = [
        types.KeyboardButton("t 5000"),
        types.KeyboardButton("t 20000"),
        types.KeyboardButton("t 50000"),
        types.KeyboardButton("T MAX")
    ]
    xiu_buttons = [
        types.KeyboardButton("x 5000"),
        types.KeyboardButton("x 20000"),
        types.KeyboardButton("x 50000"),
        types.KeyboardButton("X MAX")
    ]
    keyboard.row(*tai_buttons)
    keyboard.row(*xiu_buttons)
    bot2.send_message(message.chat.id, "Vui l√≤ng ch·ªçn c∆∞·ª£c.", reply_markup=keyboard)



def turn_on_group_chat():
    permissions = ChatPermissions(can_send_messages=True)
    bot2.set_chat_permissions(group_chat_id2, permissions)


def turn_off_group_chat():
    permissions = ChatPermissions(can_send_messages=False)
    bot2.set_chat_permissions(group_chat_id2, permissions)


load_balance_from_file()
load_session_from_file()
load_session_history_from_file()

timer_thread = threading.Thread(target=game_timer)
timer_thread.start()


def poll_bot():
    bot.polling()


def poll_bot2():
    bot2.polling()


# Kh·ªüi t·∫°o lu·ªìng cho bot2
thread_bot2 = threading.Thread(target=poll_bot2)
thread_bot2.start()

# Th√™m bot.polling() ƒë·ªÉ bot b·∫Øt ƒë·∫ßu ho·∫°t ƒë·ªông
bot.polling(none_stop=False)
bot.polling(timeout=60)



def validate_bet(user_id, bet_amount, bet_type, message, group_chat_id2, user_bets):
    total_deposit = total_deposited.get(user_id, 0)

    if bet_amount > 1000 and total_deposit < 10000:
        bot2.send_message(group_chat_id2, "‚ùå B·∫°n c·∫ßn n·∫°p √≠t nh·∫•t 10,000ƒë ƒë·ªÉ c∆∞·ª£c s·ªë ti·ªÅn l·ªõn h∆°n 1,000ƒë.")
        return True
    elif not (1000 <= bet_amount <= 100000000):
        bot2.send_message(group_chat_id2, "‚ùå S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i t·ª´ 1.000 ƒë·∫øn 100.000.000")
        return True

    opposite_bet_type = 'T' if bet_type.upper() == 'X' else 'X'
    if user_bets.get(user_id, {}).get(opposite_bet_type, 0) > 0:
        bot2.send_message(group_chat_id2, "‚ùå Kh√¥ng ƒë∆∞·ª£c c∆∞·ª£c c·∫£ hai b√™n trong m·ªôt phi√™n.")
        return True

    if confirm_bet(user_id, bet_type, bet_amount, message.message_id):
        bot2.delete_message(group_chat_id2, message.message_id)
    return False
